#include <metal_stdlib>

using namespace metal;

template<typename T, int N, int M>
inline vec<T, M> operator*(matrix<T, N, M> lhs, packed_vec<T, N> rhs) {
  return lhs * vec<T, N>(rhs);
}

template<typename T, int N, int M>
inline vec<T, N> operator*(packed_vec<T, M> lhs, matrix<T, N, M> rhs) {
  return vec<T, M>(lhs) * rhs;
}

struct VertexInput {
  float4 position;
  float3 normal;
  float4 tangent;
  float2 texcoord;
  uint4 joints;
  float4 weights;
  float4 instance0;
  float4 instance1;
  float4 instance2;
  float4 instance3;
  float4 instanceColor;
};
struct VertexOutput {
  float4 position;
  float3 worldPos;
  float3 view;
  float2 texcoord;
  float2 texcoord2;
  float4 color;
  float4 instanceColor;
  float3 normal;
  float3 tangent;
  float3 bitangent;
};
struct Camera {
  /* 0x0000 */ float4x4 projection;
  /* 0x0040 */ float4x4 inverseProjection;
  /* 0x0080 */ float4x4 view;
  /* 0x00c0 */ packed_float3 position;
  /* 0x00cc */ float time;
  /* 0x00d0 */ float2 outputSize;
  /* 0x00d8 */ float zNear;
  /* 0x00dc */ float zFar;
};
struct Joints {
  /* 0x0000 */ float4x4 matrices[1];
};
struct tint_symbol_1 {
  float4 position [[attribute(0)]];
  float3 normal [[attribute(1)]];
  float4 tangent [[attribute(2)]];
  float2 texcoord [[attribute(3)]];
  uint4 joints [[attribute(6)]];
  float4 weights [[attribute(7)]];
  float4 instance0 [[attribute(8)]];
  float4 instance1 [[attribute(9)]];
  float4 instance2 [[attribute(10)]];
  float4 instance3 [[attribute(11)]];
  float4 instanceColor [[attribute(12)]];
};
struct tint_symbol_2 {
  float3 worldPos [[user(locn0)]];
  float3 view [[user(locn1)]];
  float2 texcoord [[user(locn2)]];
  float2 texcoord2 [[user(locn3)]];
  float4 color [[user(locn4)]];
  float4 instanceColor [[user(locn5)]];
  float3 normal [[user(locn6)]];
  float3 tangent [[user(locn7)]];
  float3 bitangent [[user(locn8)]];
  float4 position [[position]];
};

float4x4 getInstanceMatrix(VertexInput input) {
  return float4x4(input.instance0, input.instance1, input.instance2, input.instance3);
}

float4x4 getSkinMatrix(VertexInput input, const device Joints* const tint_symbol_4, const device Joints* const tint_symbol_5) {
  float4x4 const joint0 = ((*(tint_symbol_4)).matrices[input.joints[0]] * (*(tint_symbol_5)).matrices[input.joints[0]]);
  float4x4 const joint1 = ((*(tint_symbol_4)).matrices[input.joints[1]] * (*(tint_symbol_5)).matrices[input.joints[1]]);
  float4x4 const joint2 = ((*(tint_symbol_4)).matrices[input.joints[2]] * (*(tint_symbol_5)).matrices[input.joints[2]]);
  float4x4 const joint3 = ((*(tint_symbol_4)).matrices[input.joints[3]] * (*(tint_symbol_5)).matrices[input.joints[3]]);
  float4x4 const skinMatrix = ((((joint0 * input.weights[0]) + (joint1 * input.weights[1])) + (joint2 * input.weights[2])) + (joint3 * input.weights[3]));
  return skinMatrix;
}

VertexOutput vertexMain_inner(VertexInput input, const device Joints* const tint_symbol_6, const device Joints* const tint_symbol_7, const constant Camera* const tint_symbol_8) {
  VertexOutput output = {};
  float4x4 const modelMatrix = getSkinMatrix(input, tint_symbol_6, tint_symbol_7);
  output.normal = normalize(float4(((modelMatrix * float4(input.normal, 0.0f)))).xyz);
  output.tangent = normalize(float4(((modelMatrix * float4(float4(input.tangent).xyz, 0.0f)))).xyz);
  output.bitangent = (cross(output.normal, output.tangent) * input.tangent[3]);
  output.color = float4(1.0f);
  output.texcoord = input.texcoord;
  output.instanceColor = input.instanceColor;
  float4 const modelPos = (modelMatrix * input.position);
  output.worldPos = float4(modelPos).xyz;
  output.view = ((*(tint_symbol_8)).position - float4(modelPos).xyz);
  output.position = (((*(tint_symbol_8)).projection * (*(tint_symbol_8)).view) * modelPos);
  return output;
}

vertex tint_symbol_2 vertexMain(const device Joints* tint_symbol_9 [[buffer(1)]], const device Joints* tint_symbol_10 [[buffer(2)]], const constant Camera* tint_symbol_11 [[buffer(0)]], tint_symbol_1 tint_symbol [[stage_in]]) {
  VertexInput const tint_symbol_3 = {.position=tint_symbol.position, .normal=tint_symbol.normal, .tangent=tint_symbol.tangent, .texcoord=tint_symbol.texcoord, .joints=tint_symbol.joints, .weights=tint_symbol.weights, .instance0=tint_symbol.instance0, .instance1=tint_symbol.instance1, .instance2=tint_symbol.instance2, .instance3=tint_symbol.instance3, .instanceColor=tint_symbol.instanceColor};
  VertexOutput const inner_result = vertexMain_inner(tint_symbol_3, tint_symbol_9, tint_symbol_10, tint_symbol_11);
  tint_symbol_2 wrapper_result = {};
  wrapper_result.position = inner_result.position;
  wrapper_result.worldPos = inner_result.worldPos;
  wrapper_result.view = inner_result.view;
  wrapper_result.texcoord = inner_result.texcoord;
  wrapper_result.texcoord2 = inner_result.texcoord2;
  wrapper_result.color = inner_result.color;
  wrapper_result.instanceColor = inner_result.instanceColor;
  wrapper_result.normal = inner_result.normal;
  wrapper_result.tangent = inner_result.tangent;
  wrapper_result.bitangent = inner_result.bitangent;
  return wrapper_result;
}

