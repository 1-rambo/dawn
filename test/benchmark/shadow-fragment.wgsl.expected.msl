#include <metal_stdlib>

using namespace metal;

template<typename T, int N, int M>
inline vec<T, M> operator*(matrix<T, N, M> lhs, packed_vec<T, N> rhs) {
  return lhs * vec<T, N>(rhs);
}

template<typename T, int N, int M>
inline vec<T, N> operator*(packed_vec<T, M> lhs, matrix<T, N, M> rhs) {
  return vec<T, M>(lhs) * rhs;
}

struct Scene {
  /* 0x0000 */ float4x4 lightViewProjMatrix;
  /* 0x0040 */ float4x4 cameraViewProjMatrix;
  /* 0x0080 */ packed_float3 lightPos;
  /* 0x008c */ int8_t tint_pad[4];
};
struct FragmentInput {
  float3 shadowPos;
  float3 fragPos;
  float3 fragNorm;
};
struct tint_symbol_2 {
  float3 shadowPos [[user(locn0)]];
  float3 fragPos [[user(locn1)]];
  float3 fragNorm [[user(locn2)]];
};
struct tint_symbol_3 {
  float4 value [[color(0)]];
};

constant float shadowDepthTextureSize = 1024.0f;
constant float3 albedo = float3(0.899999976f, 0.899999976f, 0.899999976f);
constant float ambientFactor = 0.200000003f;
float4 tint_symbol_inner(FragmentInput input, depth2d<float, access::sample> tint_symbol_5, sampler tint_symbol_6, const constant Scene* const tint_symbol_7) {
  float visibility = 0.0f;
  float const oneOverShadowDepthTextureSize = (1.0f / shadowDepthTextureSize);
  for(int y = -1; (y <= 1); y = as_type<int>((as_type<uint>(y) + as_type<uint>(1)))) {
    for(int x = -1; (x <= 1); x = as_type<int>((as_type<uint>(x) + as_type<uint>(1)))) {
      float2 const offset = float2((float(x) * oneOverShadowDepthTextureSize), (float(y) * oneOverShadowDepthTextureSize));
      visibility = (visibility + tint_symbol_5.sample_compare(tint_symbol_6, (float3(input.shadowPos).xy + offset), (input.shadowPos[2] - 0.007f)));
    }
  }
  visibility = (visibility / 9.0f);
  float const lambertFactor = fmax(dot(normalize(((*(tint_symbol_7)).lightPos - input.fragPos)), input.fragNorm), 0.0f);
  float const lightingFactor = fmin((ambientFactor + (visibility * lambertFactor)), 1.0f);
  return float4((lightingFactor * albedo), 1.0f);
}

fragment tint_symbol_3 tint_symbol(depth2d<float, access::sample> tint_symbol_8 [[texture(0)]], sampler tint_symbol_9 [[sampler(0)]], const constant Scene* tint_symbol_10 [[buffer(0)]], tint_symbol_2 tint_symbol_1 [[stage_in]]) {
  FragmentInput const tint_symbol_4 = {.shadowPos=tint_symbol_1.shadowPos, .fragPos=tint_symbol_1.fragPos, .fragNorm=tint_symbol_1.fragNorm};
  float4 const inner_result = tint_symbol_inner(tint_symbol_4, tint_symbol_8, tint_symbol_9, tint_symbol_10);
  tint_symbol_3 wrapper_result = {};
  wrapper_result.value = inner_result;
  return wrapper_result;
}

