SKIP: FAILED


@group(1) @binding(0) var<uniform> index : u32;

@group(0) @binding(0) var sampled_textures : binding_array<texture_2d<f32>, 4>;

@fragment
fn fs() {
  let texture_load = textureLoad(sampled_textures[index], vec2(0, 0), 0);
}

Failed to generate SPIR-V: :14:134 error: access: result of access chain is type 'ptr<handle, texture_2d<f32>, read>' but instruction type is 'ptr<handle, spirv.image<f32, 2d, not_depth, non_arrayed, single_sampled, sampling_compatible, undefined, read_write>, read>'
    %6:ptr<handle, spirv.image<f32, 2d, not_depth, non_arrayed, single_sampled, sampling_compatible, undefined, read_write>, read> = access %sampled_textures, %5
                                                                                                                                     ^^^^^^

:11:3 note: in block
  $B2: {
  ^^^

note: # Disassembly
index_block = struct @align(4), @block {
  inner:u32 @offset(0)
}

$B1: {  # root
  %1:ptr<uniform, index_block, read> = var undef @binding_point(1, 0)
  %sampled_textures:ptr<handle, binding_array<texture_2d<f32>, 4>, read> = var undef @binding_point(0, 0)
}

%fs = @fragment func():void {
  $B2: {
    %4:ptr<uniform, u32, read> = access %1, 0u
    %5:u32 = load %4
    %6:ptr<handle, spirv.image<f32, 2d, not_depth, non_arrayed, single_sampled, sampling_compatible, undefined, read_write>, read> = access %sampled_textures, %5
    %7:spirv.image<f32, 2d, not_depth, non_arrayed, single_sampled, sampling_compatible, undefined, read_write> = load %6
    %8:u32 = spirv.image_query_levels<u32> %7
    %9:u32 = sub %8, 1u
    %10:u32 = convert 0i
    %11:u32 = min %10, %9
    %12:vec2<u32> = spirv.image_query_size_lod %7, %11
    %13:vec2<u32> = sub %12, vec2<u32>(1u)
    %14:vec2<u32> = convert vec2<i32>(0i)
    %15:vec2<u32> = min %14, %13
    %16:vec4<f32> = spirv.image_fetch %7, %15, 2u, %11
    %texture_load:vec4<f32> = let %16
    ret
  }
}


tint executable returned error: exit status 1
