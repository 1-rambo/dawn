#include <metal_stdlib>

using namespace metal;
struct tint_symbol_1 {
  float4 value [[color(0)]];
};

void from_immediate_bool() {
  bool2 v2 = bool2(true);
  bool3 v3 = bool3(true);
  bool4 v4 = bool4(true);
}

void from_immediate_f32() {
  float2 v2 = float2(1.0f);
  float3 v3 = float3(1.0f);
  float4 v4 = float4(1.0f);
}

void from_immediate_i32() {
  int2 v2 = int2(1);
  int3 v3 = int3(1);
  int4 v4 = int4(1);
}

void from_immediate_u32() {
  uint2 v2 = uint2(1u);
  uint3 v3 = uint3(1u);
  uint4 v4 = uint4(1u);
}

void from_expression_bool() {
  bool2 v2 = bool2(true);
  bool3 v3 = bool3(true);
  bool4 v4 = bool4(true);
}

void from_expression_f32() {
  float2 v2 = float2((1.0f + 2.0f));
  float3 v3 = float3((1.0f + 2.0f));
  float4 v4 = float4((1.0f + 2.0f));
}

void from_expression_i32() {
  int2 v2 = int2((1 + 2));
  int3 v3 = int3((1 + 2));
  int4 v4 = int4((1 + 2));
}

void from_expression_u32() {
  uint2 v2 = uint2((1u + 2u));
  uint3 v3 = uint3((1u + 2u));
  uint4 v4 = uint4((1u + 2u));
}

bool get_bool() {
  return true;
}

float get_f32() {
  return 1.0f;
}

int get_i32() {
  return 1;
}

uint get_u32() {
  return 1u;
}

void from_call_bool() {
  bool2 v2 = bool2(get_bool());
  bool3 v3 = bool3(get_bool());
  bool4 v4 = bool4(get_bool());
}

void from_call_f32() {
  float2 v2 = float2(get_f32());
  float3 v3 = float3(get_f32());
  float4 v4 = float4(get_f32());
}

void from_call_i32() {
  int2 v2 = int2(get_i32());
  int3 v3 = int3(get_i32());
  int4 v4 = int4(get_i32());
}

void from_call_u32() {
  uint2 v2 = uint2(get_u32());
  uint3 v3 = uint3(get_u32());
  uint4 v4 = uint4(get_u32());
}

void with_swizzle() {
  float a = float2(1.0f).y;
  float b = float3(1.0f).z;
  float c = float4(1.0f).w;
}

fragment tint_symbol_1 tint_symbol() {
  tint_symbol_1 const tint_symbol_2 = {.value=float4(0.0f, 0.0f, 0.0f, 0.0f)};
  return tint_symbol_2;
}

