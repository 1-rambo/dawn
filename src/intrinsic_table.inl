// Copyright 2021 The Tint Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

////////////////////////////////////////////////////////////////////////////////
// File generated by tools/intrinsic-gen
// Do not modify this file directly
////////////////////////////////////////////////////////////////////////////////

// clang-format off

/// ParameterInfo describes a parameter
struct ParameterInfo {
  /// The parameter usage (parameter name in definition file)
  ParameterUsage const usage;

  /// Pointer to a list of indices that are used to match the parameter type.
  /// The matcher indices index on Matchers::type and / or Matchers::number.
  /// These indices are consumed by the matchers themselves.
  /// The first index is always a TypeMatcher.
  MatcherIndex const* const matcher_indices;
};

/// OpenTypeInfo describes an open type
struct OpenTypeInfo {
  /// Name of the open type (e.g. 'T')
  const char* name;
  /// Optional type matcher constraint.
  /// Either an index in Matchers::type, or kNoMatcher
  MatcherIndex const matcher_index;
};

/// OpenNumberInfo describes an open number
struct OpenNumberInfo {
  /// Name of the open number (e.g. 'N')
  const char* name;
  /// Optional number matcher constraint.
  /// Either an index in Matchers::number, or kNoMatcher
  MatcherIndex const matcher_index;
};

/// OverloadInfo describes a single function overload
struct OverloadInfo {
  /// Total number of parameters for the overload
  uint8_t const num_parameters;
  /// Total number of open types for the overload
  uint8_t const num_open_types;
  /// Total number of open numbers for the overload
  uint8_t const num_open_numbers;
  /// Pointer to the first open type
  OpenTypeInfo const* const open_types;
  /// Pointer to the first open number
  OpenNumberInfo const* const open_numbers;
  /// Pointer to the first parameter
  ParameterInfo const* const parameters;
  /// Pointer to a list of matcher indices that index on Matchers::type and
  /// Matchers::number, used to build the return type. If the function has no
  /// return type then this is null.
  MatcherIndex const* const return_matcher_indices;
};

/// IntrinsicInfo describes an intrinsic function
struct IntrinsicInfo {
  /// Number of overloads of the intrinsic function
  uint8_t const num_overloads;
  /// Pointer to the start of the overloads for the function
  OverloadInfo const* const overloads;
};

/// TypeMatcher for 'type bool'
/// @see src/intrinsics.def:68:6
class Bool : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* Bool::Match(MatchState& state, const sem::Type* ty) const {
  if (!match_bool(ty)) {
    return nullptr;
  }
  return build_bool(state);
}

std::string Bool::String(MatchState&) const {
  return "bool";
}

/// TypeMatcher for 'type f32'
/// @see src/intrinsics.def:69:6
class F32 : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* F32::Match(MatchState& state, const sem::Type* ty) const {
  if (!match_f32(ty)) {
    return nullptr;
  }
  return build_f32(state);
}

std::string F32::String(MatchState&) const {
  return "f32";
}

/// TypeMatcher for 'type i32'
/// @see src/intrinsics.def:70:6
class I32 : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* I32::Match(MatchState& state, const sem::Type* ty) const {
  if (!match_i32(ty)) {
    return nullptr;
  }
  return build_i32(state);
}

std::string I32::String(MatchState&) const {
  return "i32";
}

/// TypeMatcher for 'type u32'
/// @see src/intrinsics.def:71:6
class U32 : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* U32::Match(MatchState& state, const sem::Type* ty) const {
  if (!match_u32(ty)) {
    return nullptr;
  }
  return build_u32(state);
}

std::string U32::String(MatchState&) const {
  return "u32";
}

/// TypeMatcher for 'type vec2'
/// @see src/intrinsics.def:72:6
class Vec2 : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* Vec2::Match(MatchState& state, const sem::Type* ty) const {
  const sem::Type* T = nullptr;
  if (!match_vec2(ty, T)) {
    return nullptr;
  }
  T = state.Type(T);
  if (T == nullptr) {
    return nullptr;
  }
  return build_vec2(state, T);
}

std::string Vec2::String(MatchState& state) const {
  const std::string T = state.TypeName();
  return "vec2<" + T + ">";
}

/// TypeMatcher for 'type vec3'
/// @see src/intrinsics.def:73:6
class Vec3 : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* Vec3::Match(MatchState& state, const sem::Type* ty) const {
  const sem::Type* T = nullptr;
  if (!match_vec3(ty, T)) {
    return nullptr;
  }
  T = state.Type(T);
  if (T == nullptr) {
    return nullptr;
  }
  return build_vec3(state, T);
}

std::string Vec3::String(MatchState& state) const {
  const std::string T = state.TypeName();
  return "vec3<" + T + ">";
}

/// TypeMatcher for 'type vec4'
/// @see src/intrinsics.def:74:6
class Vec4 : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* Vec4::Match(MatchState& state, const sem::Type* ty) const {
  const sem::Type* T = nullptr;
  if (!match_vec4(ty, T)) {
    return nullptr;
  }
  T = state.Type(T);
  if (T == nullptr) {
    return nullptr;
  }
  return build_vec4(state, T);
}

std::string Vec4::String(MatchState& state) const {
  const std::string T = state.TypeName();
  return "vec4<" + T + ">";
}

/// TypeMatcher for 'type vec'
/// @see src/intrinsics.def:75:37
class Vec : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* Vec::Match(MatchState& state, const sem::Type* ty) const {
  Number N = Number::invalid;
  const sem::Type* T = nullptr;
  if (!match_vec(ty, N, T)) {
    return nullptr;
  }
  N = state.Num(N);
  if (!N.IsValid()) {
    return nullptr;
  }
  T = state.Type(T);
  if (T == nullptr) {
    return nullptr;
  }
  return build_vec(state, N, T);
}

std::string Vec::String(MatchState& state) const {
  const std::string N = state.NumName();
  const std::string T = state.TypeName();
  std::stringstream ss;
  ss << "vec" << N << "<" << T << ">";
  return ss.str();
}

/// TypeMatcher for 'type mat'
/// @see src/intrinsics.def:76:37
class Mat : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* Mat::Match(MatchState& state, const sem::Type* ty) const {
  Number N = Number::invalid;
  Number M = Number::invalid;
  const sem::Type* T = nullptr;
  if (!match_mat(ty, N, M, T)) {
    return nullptr;
  }
  N = state.Num(N);
  if (!N.IsValid()) {
    return nullptr;
  }
  M = state.Num(M);
  if (!M.IsValid()) {
    return nullptr;
  }
  T = state.Type(T);
  if (T == nullptr) {
    return nullptr;
  }
  return build_mat(state, N, M, T);
}

std::string Mat::String(MatchState& state) const {
  const std::string N = state.NumName();
  const std::string M = state.NumName();
  const std::string T = state.TypeName();
  std::stringstream ss;
  ss << "mat" << N << "x" << M << "<" << T << ">";
  return ss.str();
}

/// TypeMatcher for 'type ptr'
/// @see src/intrinsics.def:77:37
class Ptr : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* Ptr::Match(MatchState& state, const sem::Type* ty) const {
  Number S = Number::invalid;
  const sem::Type* T = nullptr;
  if (!match_ptr(ty, S, T)) {
    return nullptr;
  }
  S = state.Num(S);
  if (!S.IsValid()) {
    return nullptr;
  }
  T = state.Type(T);
  if (T == nullptr) {
    return nullptr;
  }
  return build_ptr(state, S, T);
}

std::string Ptr::String(MatchState& state) const {
  const std::string S = state.NumName();
  const std::string T = state.TypeName();
  std::stringstream ss;
  ss << "ptr<" << T << ">";
  return ss.str();
}

/// TypeMatcher for 'type array'
/// @see src/intrinsics.def:78:6
class Array : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* Array::Match(MatchState& state, const sem::Type* ty) const {
  const sem::Type* T = nullptr;
  if (!match_array(ty, T)) {
    return nullptr;
  }
  T = state.Type(T);
  if (T == nullptr) {
    return nullptr;
  }
  return build_array(state, T);
}

std::string Array::String(MatchState& state) const {
  const std::string T = state.TypeName();
  return "array<" + T + ">";
}

/// TypeMatcher for 'type sampler'
/// @see src/intrinsics.def:79:6
class Sampler : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* Sampler::Match(MatchState& state, const sem::Type* ty) const {
  if (!match_sampler(ty)) {
    return nullptr;
  }
  return build_sampler(state);
}

std::string Sampler::String(MatchState&) const {
  return "sampler";
}

/// TypeMatcher for 'type sampler_comparison'
/// @see src/intrinsics.def:80:6
class SamplerComparison : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* SamplerComparison::Match(MatchState& state, const sem::Type* ty) const {
  if (!match_sampler_comparison(ty)) {
    return nullptr;
  }
  return build_sampler_comparison(state);
}

std::string SamplerComparison::String(MatchState&) const {
  return "sampler_comparison";
}

/// TypeMatcher for 'type texture_1d'
/// @see src/intrinsics.def:81:6
class Texture1D : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* Texture1D::Match(MatchState& state, const sem::Type* ty) const {
  const sem::Type* T = nullptr;
  if (!match_texture_1d(ty, T)) {
    return nullptr;
  }
  T = state.Type(T);
  if (T == nullptr) {
    return nullptr;
  }
  return build_texture_1d(state, T);
}

std::string Texture1D::String(MatchState& state) const {
  const std::string T = state.TypeName();
  return "texture_1d<" + T + ">";
}

/// TypeMatcher for 'type texture_2d'
/// @see src/intrinsics.def:82:6
class Texture2D : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* Texture2D::Match(MatchState& state, const sem::Type* ty) const {
  const sem::Type* T = nullptr;
  if (!match_texture_2d(ty, T)) {
    return nullptr;
  }
  T = state.Type(T);
  if (T == nullptr) {
    return nullptr;
  }
  return build_texture_2d(state, T);
}

std::string Texture2D::String(MatchState& state) const {
  const std::string T = state.TypeName();
  return "texture_2d<" + T + ">";
}

/// TypeMatcher for 'type texture_2d_array'
/// @see src/intrinsics.def:83:6
class Texture2DArray : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* Texture2DArray::Match(MatchState& state, const sem::Type* ty) const {
  const sem::Type* T = nullptr;
  if (!match_texture_2d_array(ty, T)) {
    return nullptr;
  }
  T = state.Type(T);
  if (T == nullptr) {
    return nullptr;
  }
  return build_texture_2d_array(state, T);
}

std::string Texture2DArray::String(MatchState& state) const {
  const std::string T = state.TypeName();
  return "texture_2d_array<" + T + ">";
}

/// TypeMatcher for 'type texture_3d'
/// @see src/intrinsics.def:84:6
class Texture3D : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* Texture3D::Match(MatchState& state, const sem::Type* ty) const {
  const sem::Type* T = nullptr;
  if (!match_texture_3d(ty, T)) {
    return nullptr;
  }
  T = state.Type(T);
  if (T == nullptr) {
    return nullptr;
  }
  return build_texture_3d(state, T);
}

std::string Texture3D::String(MatchState& state) const {
  const std::string T = state.TypeName();
  return "texture_3d<" + T + ">";
}

/// TypeMatcher for 'type texture_cube'
/// @see src/intrinsics.def:85:6
class TextureCube : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* TextureCube::Match(MatchState& state, const sem::Type* ty) const {
  const sem::Type* T = nullptr;
  if (!match_texture_cube(ty, T)) {
    return nullptr;
  }
  T = state.Type(T);
  if (T == nullptr) {
    return nullptr;
  }
  return build_texture_cube(state, T);
}

std::string TextureCube::String(MatchState& state) const {
  const std::string T = state.TypeName();
  return "texture_cube<" + T + ">";
}

/// TypeMatcher for 'type texture_cube_array'
/// @see src/intrinsics.def:86:6
class TextureCubeArray : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* TextureCubeArray::Match(MatchState& state, const sem::Type* ty) const {
  const sem::Type* T = nullptr;
  if (!match_texture_cube_array(ty, T)) {
    return nullptr;
  }
  T = state.Type(T);
  if (T == nullptr) {
    return nullptr;
  }
  return build_texture_cube_array(state, T);
}

std::string TextureCubeArray::String(MatchState& state) const {
  const std::string T = state.TypeName();
  return "texture_cube_array<" + T + ">";
}

/// TypeMatcher for 'type texture_multisampled_2d'
/// @see src/intrinsics.def:87:6
class TextureMultisampled2D : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* TextureMultisampled2D::Match(MatchState& state, const sem::Type* ty) const {
  const sem::Type* T = nullptr;
  if (!match_texture_multisampled_2d(ty, T)) {
    return nullptr;
  }
  T = state.Type(T);
  if (T == nullptr) {
    return nullptr;
  }
  return build_texture_multisampled_2d(state, T);
}

std::string TextureMultisampled2D::String(MatchState& state) const {
  const std::string T = state.TypeName();
  return "texture_multisampled_2d<" + T + ">";
}

/// TypeMatcher for 'type texture_depth_2d'
/// @see src/intrinsics.def:88:6
class TextureDepth2D : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* TextureDepth2D::Match(MatchState& state, const sem::Type* ty) const {
  if (!match_texture_depth_2d(ty)) {
    return nullptr;
  }
  return build_texture_depth_2d(state);
}

std::string TextureDepth2D::String(MatchState&) const {
  return "texture_depth_2d";
}

/// TypeMatcher for 'type texture_depth_2d_array'
/// @see src/intrinsics.def:89:6
class TextureDepth2DArray : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* TextureDepth2DArray::Match(MatchState& state, const sem::Type* ty) const {
  if (!match_texture_depth_2d_array(ty)) {
    return nullptr;
  }
  return build_texture_depth_2d_array(state);
}

std::string TextureDepth2DArray::String(MatchState&) const {
  return "texture_depth_2d_array";
}

/// TypeMatcher for 'type texture_depth_cube'
/// @see src/intrinsics.def:90:6
class TextureDepthCube : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* TextureDepthCube::Match(MatchState& state, const sem::Type* ty) const {
  if (!match_texture_depth_cube(ty)) {
    return nullptr;
  }
  return build_texture_depth_cube(state);
}

std::string TextureDepthCube::String(MatchState&) const {
  return "texture_depth_cube";
}

/// TypeMatcher for 'type texture_depth_cube_array'
/// @see src/intrinsics.def:91:6
class TextureDepthCubeArray : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* TextureDepthCubeArray::Match(MatchState& state, const sem::Type* ty) const {
  if (!match_texture_depth_cube_array(ty)) {
    return nullptr;
  }
  return build_texture_depth_cube_array(state);
}

std::string TextureDepthCubeArray::String(MatchState&) const {
  return "texture_depth_cube_array";
}

/// TypeMatcher for 'type texture_storage_1d'
/// @see src/intrinsics.def:92:6
class TextureStorage1D : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* TextureStorage1D::Match(MatchState& state, const sem::Type* ty) const {
  Number F = Number::invalid;
  Number A = Number::invalid;
  if (!match_texture_storage_1d(ty, F, A)) {
    return nullptr;
  }
  F = state.Num(F);
  if (!F.IsValid()) {
    return nullptr;
  }
  A = state.Num(A);
  if (!A.IsValid()) {
    return nullptr;
  }
  return build_texture_storage_1d(state, F, A);
}

std::string TextureStorage1D::String(MatchState& state) const {
  const std::string F = state.NumName();
  const std::string A = state.NumName();
  return "texture_storage_1d<" + F + ", " + A + ">";
}

/// TypeMatcher for 'type texture_storage_2d'
/// @see src/intrinsics.def:93:6
class TextureStorage2D : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* TextureStorage2D::Match(MatchState& state, const sem::Type* ty) const {
  Number F = Number::invalid;
  Number A = Number::invalid;
  if (!match_texture_storage_2d(ty, F, A)) {
    return nullptr;
  }
  F = state.Num(F);
  if (!F.IsValid()) {
    return nullptr;
  }
  A = state.Num(A);
  if (!A.IsValid()) {
    return nullptr;
  }
  return build_texture_storage_2d(state, F, A);
}

std::string TextureStorage2D::String(MatchState& state) const {
  const std::string F = state.NumName();
  const std::string A = state.NumName();
  return "texture_storage_2d<" + F + ", " + A + ">";
}

/// TypeMatcher for 'type texture_storage_2d_array'
/// @see src/intrinsics.def:94:6
class TextureStorage2DArray : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* TextureStorage2DArray::Match(MatchState& state, const sem::Type* ty) const {
  Number F = Number::invalid;
  Number A = Number::invalid;
  if (!match_texture_storage_2d_array(ty, F, A)) {
    return nullptr;
  }
  F = state.Num(F);
  if (!F.IsValid()) {
    return nullptr;
  }
  A = state.Num(A);
  if (!A.IsValid()) {
    return nullptr;
  }
  return build_texture_storage_2d_array(state, F, A);
}

std::string TextureStorage2DArray::String(MatchState& state) const {
  const std::string F = state.NumName();
  const std::string A = state.NumName();
  return "texture_storage_2d_array<" + F + ", " + A + ">";
}

/// TypeMatcher for 'type texture_storage_3d'
/// @see src/intrinsics.def:95:6
class TextureStorage3D : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* TextureStorage3D::Match(MatchState& state, const sem::Type* ty) const {
  Number F = Number::invalid;
  Number A = Number::invalid;
  if (!match_texture_storage_3d(ty, F, A)) {
    return nullptr;
  }
  F = state.Num(F);
  if (!F.IsValid()) {
    return nullptr;
  }
  A = state.Num(A);
  if (!A.IsValid()) {
    return nullptr;
  }
  return build_texture_storage_3d(state, F, A);
}

std::string TextureStorage3D::String(MatchState& state) const {
  const std::string F = state.NumName();
  const std::string A = state.NumName();
  return "texture_storage_3d<" + F + ", " + A + ">";
}

/// TypeMatcher for 'type texture_external'
/// @see src/intrinsics.def:96:6
class TextureExternal : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* TextureExternal::Match(MatchState& state, const sem::Type* ty) const {
  if (!match_texture_external(ty)) {
    return nullptr;
  }
  return build_texture_external(state);
}

std::string TextureExternal::String(MatchState&) const {
  return "texture_external";
}

/// TypeMatcher for 'match fiu32'
/// @see src/intrinsics.def:104:7
class Fiu32 : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules, and returns the
  /// expected, canonicalized type on success.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* Fiu32::Match(MatchState& state, const sem::Type* ty) const {
  if (match_f32(ty)) {
    return build_f32(state);
  }
  if (match_i32(ty)) {
    return build_i32(state);
  }
  if (match_u32(ty)) {
    return build_u32(state);
  }
  return nullptr;
}

std::string Fiu32::String(MatchState&) const {
  return "f32, i32 or u32";
}

/// TypeMatcher for 'match iu32'
/// @see src/intrinsics.def:105:7
class Iu32 : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules, and returns the
  /// expected, canonicalized type on success.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* Iu32::Match(MatchState& state, const sem::Type* ty) const {
  if (match_i32(ty)) {
    return build_i32(state);
  }
  if (match_u32(ty)) {
    return build_u32(state);
  }
  return nullptr;
}

std::string Iu32::String(MatchState&) const {
  return "i32 or u32";
}

/// TypeMatcher for 'match scalar'
/// @see src/intrinsics.def:106:7
class Scalar : public TypeMatcher {
 public:
  /// Checks whether the given type matches the matcher rules, and returns the
  /// expected, canonicalized type on success.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param type the type to match
  /// @returns the canonicalized type on match, otherwise nullptr
  const sem::Type* Match(MatchState& state,
                         const sem::Type* type) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

const sem::Type* Scalar::Match(MatchState& state, const sem::Type* ty) const {
  if (match_f32(ty)) {
    return build_f32(state);
  }
  if (match_i32(ty)) {
    return build_i32(state);
  }
  if (match_u32(ty)) {
    return build_u32(state);
  }
  if (match_bool(ty)) {
    return build_bool(state);
  }
  return nullptr;
}

std::string Scalar::String(MatchState&) const {
  return "f32, i32, u32 or bool";
}

/// EnumMatcher for 'match f32_texel_format'
/// @see src/intrinsics.def:117:7
class F32TexelFormat : public NumberMatcher {
 public:
  /// Checks whether the given number matches the enum matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param number the enum value as a Number
  /// @return true if the enum value matches the set
  Number Match(MatchState& state, Number number) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

Number F32TexelFormat::Match(MatchState&, Number number) const {
  switch (static_cast<TexelFormat>(number.Value())) {
    case TexelFormat::kRgba8Unorm:
    case TexelFormat::kRgba8Snorm:
    case TexelFormat::kRgba16Float:
    case TexelFormat::kR32Float:
    case TexelFormat::kRg32Float:
    case TexelFormat::kRgba32Float:
      return number;
    default:
      return Number::invalid;
  }
}

std::string F32TexelFormat::String(MatchState&) const {
  return "rgba8unorm, rgba8snorm, rgba16float, r32float, rg32float or rgba32float";
}

/// EnumMatcher for 'match i32_texel_format'
/// @see src/intrinsics.def:119:7
class I32TexelFormat : public NumberMatcher {
 public:
  /// Checks whether the given number matches the enum matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param number the enum value as a Number
  /// @return true if the enum value matches the set
  Number Match(MatchState& state, Number number) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

Number I32TexelFormat::Match(MatchState&, Number number) const {
  switch (static_cast<TexelFormat>(number.Value())) {
    case TexelFormat::kRgba8Sint:
    case TexelFormat::kRgba16Sint:
    case TexelFormat::kR32Sint:
    case TexelFormat::kRg32Sint:
    case TexelFormat::kRgba32Sint:
      return number;
    default:
      return Number::invalid;
  }
}

std::string I32TexelFormat::String(MatchState&) const {
  return "rgba8sint, rgba16sint, r32sint, rg32sint or rgba32sint";
}

/// EnumMatcher for 'match u32_texel_format'
/// @see src/intrinsics.def:121:7
class U32TexelFormat : public NumberMatcher {
 public:
  /// Checks whether the given number matches the enum matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param number the enum value as a Number
  /// @return true if the enum value matches the set
  Number Match(MatchState& state, Number number) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

Number U32TexelFormat::Match(MatchState&, Number number) const {
  switch (static_cast<TexelFormat>(number.Value())) {
    case TexelFormat::kRgba8Uint:
    case TexelFormat::kRgba16Uint:
    case TexelFormat::kR32Uint:
    case TexelFormat::kRg32Uint:
    case TexelFormat::kRgba32Uint:
      return number;
    default:
      return Number::invalid;
  }
}

std::string U32TexelFormat::String(MatchState&) const {
  return "rgba8uint, rgba16uint, r32uint, rg32uint or rgba32uint";
}

/// EnumMatcher for 'match read_or_write'
/// @see src/intrinsics.def:124:7
class ReadOrWrite : public NumberMatcher {
 public:
  /// Checks whether the given number matches the enum matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param number the enum value as a Number
  /// @return true if the enum value matches the set
  Number Match(MatchState& state, Number number) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

Number ReadOrWrite::Match(MatchState&, Number number) const {
  switch (static_cast<AccessControl>(number.Value())) {
    case AccessControl::kRead:
    case AccessControl::kWrite:
      return number;
    default:
      return Number::invalid;
  }
}

std::string ReadOrWrite::String(MatchState&) const {
  return "read or write";
}

/// EnumMatcher for 'match write'
class Write : public NumberMatcher {
 public:
  /// Checks whether the given number matches the enum matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param number the enum value as a Number
  /// @return true if the enum value matches the set
  Number Match(MatchState& state, Number number) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

Number Write::Match(MatchState&, Number number) const {
  if (number.IsAny() || number.Value() == static_cast<uint32_t>(AccessControl::kWrite)) {
    return Number(AccessControl::kWrite);
  }
  return Number::invalid;
}

std::string Write::String(MatchState&) const {
  return "write";
}

/// EnumMatcher for 'match read'
class Read : public NumberMatcher {
 public:
  /// Checks whether the given number matches the enum matcher rules.
  /// Match may close open types and numbers in state.
  /// @param state the MatchState
  /// @param number the enum value as a Number
  /// @return true if the enum value matches the set
  Number Match(MatchState& state, Number number) const override;
  /// @param state the MatchState
  /// @return a string representation of the matcher.
  std::string String(MatchState& state) const override;
};

Number Read::Match(MatchState&, Number number) const {
  if (number.IsAny() || number.Value() == static_cast<uint32_t>(AccessControl::kRead)) {
    return Number(AccessControl::kRead);
  }
  return Number::invalid;
}

std::string Read::String(MatchState&) const {
  return "read";
}

/// Matchers holds type and number matchers
class Matchers {
 private:
  OpenTypeMatcher open_type_0_{0};
  OpenNumberMatcher open_number_0_{0};
  OpenNumberMatcher open_number_1_{1};
  Bool Bool_;
  F32 F32_;
  I32 I32_;
  U32 U32_;
  Vec2 Vec2_;
  Vec3 Vec3_;
  Vec4 Vec4_;
  Vec Vec_;
  Mat Mat_;
  Ptr Ptr_;
  Array Array_;
  Sampler Sampler_;
  SamplerComparison SamplerComparison_;
  Texture1D Texture1D_;
  Texture2D Texture2D_;
  Texture2DArray Texture2DArray_;
  Texture3D Texture3D_;
  TextureCube TextureCube_;
  TextureCubeArray TextureCubeArray_;
  TextureMultisampled2D TextureMultisampled2D_;
  TextureDepth2D TextureDepth2D_;
  TextureDepth2DArray TextureDepth2DArray_;
  TextureDepthCube TextureDepthCube_;
  TextureDepthCubeArray TextureDepthCubeArray_;
  TextureStorage1D TextureStorage1D_;
  TextureStorage2D TextureStorage2D_;
  TextureStorage2DArray TextureStorage2DArray_;
  TextureStorage3D TextureStorage3D_;
  TextureExternal TextureExternal_;
  Fiu32 Fiu32_;
  Iu32 Iu32_;
  Scalar Scalar_;
  F32TexelFormat F32TexelFormat_;
  I32TexelFormat I32TexelFormat_;
  U32TexelFormat U32TexelFormat_;
  ReadOrWrite ReadOrWrite_;
  Write Write_;
  Read Read_;

 public:
  /// Constructor
  Matchers();
  /// Destructor
  ~Matchers();

  /// The open-types, types, and type matchers
  TypeMatcher const* const type[33] = {
    /* [0] */ &open_type_0_,
    /* [1] */ &Bool_,
    /* [2] */ &F32_,
    /* [3] */ &I32_,
    /* [4] */ &U32_,
    /* [5] */ &Vec2_,
    /* [6] */ &Vec3_,
    /* [7] */ &Vec4_,
    /* [8] */ &Vec_,
    /* [9] */ &Mat_,
    /* [10] */ &Ptr_,
    /* [11] */ &Array_,
    /* [12] */ &Sampler_,
    /* [13] */ &SamplerComparison_,
    /* [14] */ &Texture1D_,
    /* [15] */ &Texture2D_,
    /* [16] */ &Texture2DArray_,
    /* [17] */ &Texture3D_,
    /* [18] */ &TextureCube_,
    /* [19] */ &TextureCubeArray_,
    /* [20] */ &TextureMultisampled2D_,
    /* [21] */ &TextureDepth2D_,
    /* [22] */ &TextureDepth2DArray_,
    /* [23] */ &TextureDepthCube_,
    /* [24] */ &TextureDepthCubeArray_,
    /* [25] */ &TextureStorage1D_,
    /* [26] */ &TextureStorage2D_,
    /* [27] */ &TextureStorage2DArray_,
    /* [28] */ &TextureStorage3D_,
    /* [29] */ &TextureExternal_,
    /* [30] */ &Fiu32_,
    /* [31] */ &Iu32_,
    /* [32] */ &Scalar_,
  };

  /// The open-numbers, and number matchers
  NumberMatcher const* const number[8] = {
    /* [0] */ &open_number_0_,
    /* [1] */ &open_number_1_,
    /* [2] */ &F32TexelFormat_,
    /* [3] */ &I32TexelFormat_,
    /* [4] */ &U32TexelFormat_,
    /* [5] */ &ReadOrWrite_,
    /* [6] */ &Write_,
    /* [7] */ &Read_,
  };
};

Matchers::Matchers() = default;
Matchers::~Matchers() = default;

constexpr MatcherIndex kMatcherIndices[] = {
  /* [0] */ 10,
  /* [1] */ 1,
  /* [2] */ 8,
  /* [3] */ 0,
  /* [4] */ 0,
  /* [5] */ 10,
  /* [6] */ 1,
  /* [7] */ 8,
  /* [8] */ 0,
  /* [9] */ 2,
  /* [10] */ 9,
  /* [11] */ 0,
  /* [12] */ 0,
  /* [13] */ 2,
  /* [14] */ 26,
  /* [15] */ 2,
  /* [16] */ 6,
  /* [17] */ 2,
  /* [18] */ 28,
  /* [19] */ 0,
  /* [20] */ 1,
  /* [21] */ 27,
  /* [22] */ 0,
  /* [23] */ 1,
  /* [24] */ 8,
  /* [25] */ 0,
  /* [26] */ 1,
  /* [27] */ 28,
  /* [28] */ 4,
  /* [29] */ 7,
  /* [30] */ 2,
  /* [31] */ 26,
  /* [32] */ 0,
  /* [33] */ 1,
  /* [34] */ 25,
  /* [35] */ 0,
  /* [36] */ 1,
  /* [37] */ 27,
  /* [38] */ 4,
  /* [39] */ 7,
  /* [40] */ 3,
  /* [41] */ 26,
  /* [42] */ 4,
  /* [43] */ 7,
  /* [44] */ 4,
  /* [45] */ 25,
  /* [46] */ 4,
  /* [47] */ 7,
  /* [48] */ 0,
  /* [49] */ 28,
  /* [50] */ 3,
  /* [51] */ 7,
  /* [52] */ 27,
  /* [53] */ 3,
  /* [54] */ 7,
  /* [55] */ 26,
  /* [56] */ 3,
  /* [57] */ 7,
  /* [58] */ 25,
  /* [59] */ 3,
  /* [60] */ 7,
  /* [61] */ 28,
  /* [62] */ 2,
  /* [63] */ 7,
  /* [64] */ 27,
  /* [65] */ 2,
  /* [66] */ 7,
  /* [67] */ 26,
  /* [68] */ 2,
  /* [69] */ 7,
  /* [70] */ 25,
  /* [71] */ 2,
  /* [72] */ 7,
  /* [73] */ 28,
  /* [74] */ 4,
  /* [75] */ 6,
  /* [76] */ 3,
  /* [77] */ 10,
  /* [78] */ 0,
  /* [79] */ 2,
  /* [80] */ 27,
  /* [81] */ 4,
  /* [82] */ 6,
  /* [83] */ 26,
  /* [84] */ 4,
  /* [85] */ 6,
  /* [86] */ 10,
  /* [87] */ 0,
  /* [88] */ 0,
  /* [89] */ 25,
  /* [90] */ 4,
  /* [91] */ 6,
  /* [92] */ 28,
  /* [93] */ 3,
  /* [94] */ 6,
  /* [95] */ 27,
  /* [96] */ 3,
  /* [97] */ 6,
  /* [98] */ 26,
  /* [99] */ 3,
  /* [100] */ 6,
  /* [101] */ 25,
  /* [102] */ 3,
  /* [103] */ 6,
  /* [104] */ 28,
  /* [105] */ 2,
  /* [106] */ 6,
  /* [107] */ 25,
  /* [108] */ 2,
  /* [109] */ 6,
  /* [110] */ 27,
  /* [111] */ 2,
  /* [112] */ 6,
  /* [113] */ 5,
  /* [114] */ 3,
  /* [115] */ 5,
  /* [116] */ 2,
  /* [117] */ 19,
  /* [118] */ 2,
  /* [119] */ 18,
  /* [120] */ 2,
  /* [121] */ 14,
  /* [122] */ 0,
  /* [123] */ 17,
  /* [124] */ 2,
  /* [125] */ 15,
  /* [126] */ 0,
  /* [127] */ 16,
  /* [128] */ 2,
  /* [129] */ 16,
  /* [130] */ 0,
  /* [131] */ 17,
  /* [132] */ 0,
  /* [133] */ 20,
  /* [134] */ 0,
  /* [135] */ 15,
  /* [136] */ 2,
  /* [137] */ 18,
  /* [138] */ 0,
  /* [139] */ 19,
  /* [140] */ 0,
  /* [141] */ 11,
  /* [142] */ 0,
  /* [143] */ 14,
  /* [144] */ 2,
  /* [145] */ 12,
  /* [146] */ 22,
  /* [147] */ 23,
  /* [148] */ 21,
  /* [149] */ 24,
  /* [150] */ 29,
  /* [151] */ 13,
};

// Assert that the MatcherIndex is big enough to index all the matchers, plus
// kNoMatcher.
static_assert(static_cast<int>(sizeof(kMatcherIndices) / sizeof(kMatcherIndices[0])) <
              static_cast<int>(std::numeric_limits<MatcherIndex>::max() - 1),
              "MatcherIndex is not large enough to index kMatcherIndices");

constexpr ParameterInfo kParameters[] = {
  {
    /* [0] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[127],
  },
  {
    /* [1] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [2] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [3] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [4] */
    /* usage */ ParameterUsage::kDdx,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [5] */
    /* usage */ ParameterUsage::kDdy,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [6] */
    /* usage */ ParameterUsage::kOffset,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [7] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[135],
  },
  {
    /* [8] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [9] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [10] */
    /* usage */ ParameterUsage::kDdx,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [11] */
    /* usage */ ParameterUsage::kDdy,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [12] */
    /* usage */ ParameterUsage::kOffset,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [13] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[117],
  },
  {
    /* [14] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [15] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [16] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [17] */
    /* usage */ ParameterUsage::kDdx,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [18] */
    /* usage */ ParameterUsage::kDdy,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [19] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[127],
  },
  {
    /* [20] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [21] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [22] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [23] */
    /* usage */ ParameterUsage::kDdx,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [24] */
    /* usage */ ParameterUsage::kDdy,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [25] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[146],
  },
  {
    /* [26] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[151],
  },
  {
    /* [27] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [28] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [29] */
    /* usage */ ParameterUsage::kDepthRef,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [30] */
    /* usage */ ParameterUsage::kOffset,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [31] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[123],
  },
  {
    /* [32] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [33] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [34] */
    /* usage */ ParameterUsage::kDdx,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [35] */
    /* usage */ ParameterUsage::kDdy,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [36] */
    /* usage */ ParameterUsage::kOffset,
    /* matcher indices */ &kMatcherIndices[75],
  },
  {
    /* [37] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[146],
  },
  {
    /* [38] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [39] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [40] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [41] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [42] */
    /* usage */ ParameterUsage::kOffset,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [43] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[127],
  },
  {
    /* [44] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [45] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [46] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [47] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [48] */
    /* usage */ ParameterUsage::kOffset,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [49] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[127],
  },
  {
    /* [50] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [51] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [52] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [53] */
    /* usage */ ParameterUsage::kBias,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [54] */
    /* usage */ ParameterUsage::kOffset,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [55] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[146],
  },
  {
    /* [56] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[151],
  },
  {
    /* [57] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [58] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [59] */
    /* usage */ ParameterUsage::kDepthRef,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [60] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[127],
  },
  {
    /* [61] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [62] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [63] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [64] */
    /* usage */ ParameterUsage::kOffset,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [65] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[146],
  },
  {
    /* [66] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [67] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [68] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [69] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [70] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[148],
  },
  {
    /* [71] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[151],
  },
  {
    /* [72] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [73] */
    /* usage */ ParameterUsage::kDepthRef,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [74] */
    /* usage */ ParameterUsage::kOffset,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [75] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[149],
  },
  {
    /* [76] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [77] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [78] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [79] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [80] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[123],
  },
  {
    /* [81] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [82] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [83] */
    /* usage */ ParameterUsage::kBias,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [84] */
    /* usage */ ParameterUsage::kOffset,
    /* matcher indices */ &kMatcherIndices[75],
  },
  {
    /* [85] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[146],
  },
  {
    /* [86] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [87] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [88] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [89] */
    /* usage */ ParameterUsage::kOffset,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [90] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[127],
  },
  {
    /* [91] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [92] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [93] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [94] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [95] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[117],
  },
  {
    /* [96] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [97] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [98] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [99] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [100] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[135],
  },
  {
    /* [101] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [102] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [103] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [104] */
    /* usage */ ParameterUsage::kOffset,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [105] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[135],
  },
  {
    /* [106] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [107] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [108] */
    /* usage */ ParameterUsage::kBias,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [109] */
    /* usage */ ParameterUsage::kOffset,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [110] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[149],
  },
  {
    /* [111] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[151],
  },
  {
    /* [112] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [113] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [114] */
    /* usage */ ParameterUsage::kDepthRef,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [115] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[135],
  },
  {
    /* [116] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [117] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [118] */
    /* usage */ ParameterUsage::kDdx,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [119] */
    /* usage */ ParameterUsage::kDdy,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [120] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[117],
  },
  {
    /* [121] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [122] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [123] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [124] */
    /* usage */ ParameterUsage::kBias,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [125] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[148],
  },
  {
    /* [126] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [127] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [128] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [129] */
    /* usage */ ParameterUsage::kOffset,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [130] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[127],
  },
  {
    /* [131] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [132] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [133] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [134] */
    /* usage */ ParameterUsage::kBias,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [135] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[123],
  },
  {
    /* [136] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [137] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [138] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [139] */
    /* usage */ ParameterUsage::kOffset,
    /* matcher indices */ &kMatcherIndices[75],
  },
  {
    /* [140] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[119],
  },
  {
    /* [141] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [142] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [143] */
    /* usage */ ParameterUsage::kDdx,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [144] */
    /* usage */ ParameterUsage::kDdy,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [145] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[123],
  },
  {
    /* [146] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [147] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [148] */
    /* usage */ ParameterUsage::kDdx,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [149] */
    /* usage */ ParameterUsage::kDdy,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [150] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[129],
  },
  {
    /* [151] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [152] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [153] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [154] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[117],
  },
  {
    /* [155] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [156] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [157] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [158] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[80],
  },
  {
    /* [159] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [160] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [161] */
    /* usage */ ParameterUsage::kValue,
    /* matcher indices */ &kMatcherIndices[43],
  },
  {
    /* [162] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[95],
  },
  {
    /* [163] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [164] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [165] */
    /* usage */ ParameterUsage::kValue,
    /* matcher indices */ &kMatcherIndices[39],
  },
  {
    /* [166] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[148],
  },
  {
    /* [167] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [168] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [169] */
    /* usage */ ParameterUsage::kOffset,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [170] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[123],
  },
  {
    /* [171] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [172] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [173] */
    /* usage */ ParameterUsage::kOffset,
    /* matcher indices */ &kMatcherIndices[75],
  },
  {
    /* [174] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[135],
  },
  {
    /* [175] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [176] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [177] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [178] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[110],
  },
  {
    /* [179] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [180] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [181] */
    /* usage */ ParameterUsage::kValue,
    /* matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [182] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[147],
  },
  {
    /* [183] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[151],
  },
  {
    /* [184] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [185] */
    /* usage */ ParameterUsage::kDepthRef,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [186] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[119],
  },
  {
    /* [187] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [188] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [189] */
    /* usage */ ParameterUsage::kBias,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [190] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[146],
  },
  {
    /* [191] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [192] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [193] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [194] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[146],
  },
  {
    /* [195] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [196] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [197] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [198] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[147],
  },
  {
    /* [199] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [200] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [201] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [202] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[119],
  },
  {
    /* [203] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [204] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [205] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [206] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[148],
  },
  {
    /* [207] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[151],
  },
  {
    /* [208] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [209] */
    /* usage */ ParameterUsage::kDepthRef,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [210] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[123],
  },
  {
    /* [211] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [212] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [213] */
    /* usage */ ParameterUsage::kBias,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [214] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[127],
  },
  {
    /* [215] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [216] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [217] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [218] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[123],
  },
  {
    /* [219] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [220] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [221] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [222] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[148],
  },
  {
    /* [223] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [224] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [225] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [226] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[149],
  },
  {
    /* [227] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [228] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [229] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [230] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[135],
  },
  {
    /* [231] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [232] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [233] */
    /* usage */ ParameterUsage::kBias,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [234] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[135],
  },
  {
    /* [235] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [236] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [237] */
    /* usage */ ParameterUsage::kOffset,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [238] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[101],
  },
  {
    /* [239] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [240] */
    /* usage */ ParameterUsage::kValue,
    /* matcher indices */ &kMatcherIndices[39],
  },
  {
    /* [241] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [242] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [243] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [244] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[2],
  },
  {
    /* [245] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[2],
  },
  {
    /* [246] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[24],
  },
  {
    /* [247] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[3],
  },
  {
    /* [248] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[3],
  },
  {
    /* [249] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[1],
  },
  {
    /* [250] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [251] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [252] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [253] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [254] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [255] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [256] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[150],
  },
  {
    /* [257] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [258] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [259] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[14],
  },
  {
    /* [260] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [261] */
    /* usage */ ParameterUsage::kValue,
    /* matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [262] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[104],
  },
  {
    /* [263] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[75],
  },
  {
    /* [264] */
    /* usage */ ParameterUsage::kValue,
    /* matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [265] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[92],
  },
  {
    /* [266] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[75],
  },
  {
    /* [267] */
    /* usage */ ParameterUsage::kValue,
    /* matcher indices */ &kMatcherIndices[39],
  },
  {
    /* [268] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[89],
  },
  {
    /* [269] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [270] */
    /* usage */ ParameterUsage::kValue,
    /* matcher indices */ &kMatcherIndices[43],
  },
  {
    /* [271] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[83],
  },
  {
    /* [272] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [273] */
    /* usage */ ParameterUsage::kValue,
    /* matcher indices */ &kMatcherIndices[43],
  },
  {
    /* [274] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[148],
  },
  {
    /* [275] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [276] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [277] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[119],
  },
  {
    /* [278] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [279] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [280] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [281] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [282] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [283] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[73],
  },
  {
    /* [284] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[75],
  },
  {
    /* [285] */
    /* usage */ ParameterUsage::kValue,
    /* matcher indices */ &kMatcherIndices[43],
  },
  {
    /* [286] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[121],
  },
  {
    /* [287] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [288] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [289] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[125],
  },
  {
    /* [290] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [291] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [292] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[131],
  },
  {
    /* [293] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[75],
  },
  {
    /* [294] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [295] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[133],
  },
  {
    /* [296] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [297] */
    /* usage */ ParameterUsage::kSampleIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [298] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[2],
  },
  {
    /* [299] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[2],
  },
  {
    /* [300] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[2],
  },
  {
    /* [301] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[3],
  },
  {
    /* [302] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[3],
  },
  {
    /* [303] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[3],
  },
  {
    /* [304] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[148],
  },
  {
    /* [305] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [306] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [307] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[123],
  },
  {
    /* [308] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [309] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [310] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [311] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [312] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [313] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[64],
  },
  {
    /* [314] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [315] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [316] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[147],
  },
  {
    /* [317] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [318] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [319] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[135],
  },
  {
    /* [320] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [321] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [322] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[52],
  },
  {
    /* [323] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [324] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [325] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[150],
  },
  {
    /* [326] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [327] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [328] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[143],
  },
  {
    /* [329] */
    /* usage */ ParameterUsage::kSampler,
    /* matcher indices */ &kMatcherIndices[145],
  },
  {
    /* [330] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [331] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[37],
  },
  {
    /* [332] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [333] */
    /* usage */ ParameterUsage::kArrayIndex,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [334] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [335] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [336] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [337] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [338] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [339] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [340] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[107],
  },
  {
    /* [341] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [342] */
    /* usage */ ParameterUsage::kValue,
    /* matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [343] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [344] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [345] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [346] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[98],
  },
  {
    /* [347] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [348] */
    /* usage */ ParameterUsage::kValue,
    /* matcher indices */ &kMatcherIndices[39],
  },
  {
    /* [349] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [350] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[5],
  },
  {
    /* [351] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [352] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[77],
  },
  {
    /* [353] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[2],
  },
  {
    /* [354] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[2],
  },
  {
    /* [355] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[3],
  },
  {
    /* [356] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[3],
  },
  {
    /* [357] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[2],
  },
  {
    /* [358] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[2],
  },
  {
    /* [359] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [360] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [361] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [362] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [363] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [364] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [365] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [366] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [367] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[3],
  },
  {
    /* [368] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[3],
  },
  {
    /* [369] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[150],
  },
  {
    /* [370] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [371] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [372] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[2],
  },
  {
    /* [373] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [374] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[3],
  },
  {
    /* [375] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [376] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[0],
  },
  {
    /* [377] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [378] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[86],
  },
  {
    /* [379] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[125],
  },
  {
    /* [380] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [381] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [382] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [383] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [384] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [385] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [386] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [387] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [388] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [389] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [390] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [391] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [392] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [393] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[70],
  },
  {
    /* [394] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [395] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[67],
  },
  {
    /* [396] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [397] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[61],
  },
  {
    /* [398] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[75],
  },
  {
    /* [399] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [400] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [401] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [402] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [403] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[27],
  },
  {
    /* [404] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[75],
  },
  {
    /* [405] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[58],
  },
  {
    /* [406] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [407] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[55],
  },
  {
    /* [408] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [409] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[49],
  },
  {
    /* [410] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[75],
  },
  {
    /* [411] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[45],
  },
  {
    /* [412] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [413] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[149],
  },
  {
    /* [414] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [415] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[147],
  },
  {
    /* [416] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [417] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[146],
  },
  {
    /* [418] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [419] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[148],
  },
  {
    /* [420] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [421] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[139],
  },
  {
    /* [422] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [423] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[137],
  },
  {
    /* [424] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [425] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[131],
  },
  {
    /* [426] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [427] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[41],
  },
  {
    /* [428] */
    /* usage */ ParameterUsage::kCoords,
    /* matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [429] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[129],
  },
  {
    /* [430] */
    /* usage */ ParameterUsage::kLevel,
    /* matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [431] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[125],
  },
  {
    /* [432] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[125],
  },
  {
    /* [433] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[129],
  },
  {
    /* [434] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[121],
  },
  {
    /* [435] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[131],
  },
  {
    /* [436] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[28],
  },
  {
    /* [437] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[137],
  },
  {
    /* [438] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[28],
  },
  {
    /* [439] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[139],
  },
  {
    /* [440] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[28],
  },
  {
    /* [441] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[133],
  },
  {
    /* [442] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[148],
  },
  {
    /* [443] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[28],
  },
  {
    /* [444] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[146],
  },
  {
    /* [445] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[28],
  },
  {
    /* [446] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[147],
  },
  {
    /* [447] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [448] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[149],
  },
  {
    /* [449] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [450] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[34],
  },
  {
    /* [451] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[31],
  },
  {
    /* [452] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[21],
  },
  {
    /* [453] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[18],
  },
  {
    /* [454] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[150],
  },
  {
    /* [455] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[129],
  },
  {
    /* [456] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[139],
  },
  {
    /* [457] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[146],
  },
  {
    /* [458] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[149],
  },
  {
    /* [459] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[21],
  },
  {
    /* [460] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [461] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[129],
  },
  {
    /* [462] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[131],
  },
  {
    /* [463] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[137],
  },
  {
    /* [464] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[139],
  },
  {
    /* [465] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[148],
  },
  {
    /* [466] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[146],
  },
  {
    /* [467] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[147],
  },
  {
    /* [468] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[149],
  },
  {
    /* [469] */
    /* usage */ ParameterUsage::kTexture,
    /* matcher indices */ &kMatcherIndices[133],
  },
  {
    /* [470] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [471] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [472] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [473] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [474] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [475] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [476] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [477] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [478] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [479] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [480] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [481] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [482] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [483] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[2],
  },
  {
    /* [484] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[3],
  },
  {
    /* [485] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [486] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [487] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [488] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [489] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [490] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [491] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [492] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [493] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [494] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [495] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [496] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [497] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [498] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [499] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [500] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [501] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [502] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [503] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [504] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [505] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [506] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [507] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [508] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [509] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [510] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [511] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [512] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [513] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [514] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [515] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [516] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [517] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [518] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [519] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [520] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [521] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [522] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [523] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [524] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [525] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [526] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [527] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [528] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [529] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [530] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [531] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [532] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [533] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[10],
  },
  {
    /* [534] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[2],
  },
  {
    /* [535] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[3],
  },
  {
    /* [536] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [537] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [538] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [539] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [540] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [541] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [542] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [543] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [544] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [545] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [546] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[141],
  },
  {
    /* [547] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[24],
  },
  {
    /* [548] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[24],
  },
  {
    /* [549] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [550] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [551] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[2],
  },
  {
    /* [552] */
    /* usage */ ParameterUsage::kNone,
    /* matcher indices */ &kMatcherIndices[3],
  },
};

constexpr OpenTypeInfo kOpenTypes[] = {
  {
    /* [0] */
    /* name */ "T",
    /* matcher index */ 31,
  },
  {
    /* [1] */
    /* name */ "T",
    /* matcher index */ 30,
  },
  {
    /* [2] */
    /* name */ "T",
    /* matcher index */ kNoMatcher,
  },
  {
    /* [3] */
    /* name */ "T",
    /* matcher index */ 32,
  },
};

constexpr OpenNumberInfo kOpenNumbers[] = {
  {
    /* [0] */
    /* name */ "F",
    /* matcher index */ kNoMatcher,
  },
  {
    /* [1] */
    /* name */ "A",
    /* matcher index */ 5,
  },
  {
    /* [2] */
    /* name */ "N",
    /* matcher index */ kNoMatcher,
  },
  {
    /* [3] */
    /* name */ "S",
    /* matcher index */ kNoMatcher,
  },
};

constexpr OverloadInfo kOverloads[] = {
  {
    /* [0] */
    /* num parameters */ 1,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[434],
    /* return matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [1] */
    /* num parameters */ 1,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[432],
    /* return matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [2] */
    /* num parameters */ 2,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[379],
    /* return matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [3] */
    /* num parameters */ 1,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[433],
    /* return matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [4] */
    /* num parameters */ 2,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[429],
    /* return matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [5] */
    /* num parameters */ 1,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[435],
    /* return matcher indices */ &kMatcherIndices[75],
  },
  {
    /* [6] */
    /* num parameters */ 2,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[425],
    /* return matcher indices */ &kMatcherIndices[75],
  },
  {
    /* [7] */
    /* num parameters */ 1,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[437],
    /* return matcher indices */ &kMatcherIndices[75],
  },
  {
    /* [8] */
    /* num parameters */ 2,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[423],
    /* return matcher indices */ &kMatcherIndices[75],
  },
  {
    /* [9] */
    /* num parameters */ 1,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[439],
    /* return matcher indices */ &kMatcherIndices[75],
  },
  {
    /* [10] */
    /* num parameters */ 2,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[421],
    /* return matcher indices */ &kMatcherIndices[75],
  },
  {
    /* [11] */
    /* num parameters */ 1,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[441],
    /* return matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [12] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[442],
    /* return matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [13] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[419],
    /* return matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [14] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[444],
    /* return matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [15] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[417],
    /* return matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [16] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[446],
    /* return matcher indices */ &kMatcherIndices[75],
  },
  {
    /* [17] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[415],
    /* return matcher indices */ &kMatcherIndices[75],
  },
  {
    /* [18] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[448],
    /* return matcher indices */ &kMatcherIndices[75],
  },
  {
    /* [19] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[413],
    /* return matcher indices */ &kMatcherIndices[75],
  },
  {
    /* [20] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 2,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[0],
    /* parameters */ &kParameters[450],
    /* return matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [21] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 2,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[0],
    /* parameters */ &kParameters[451],
    /* return matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [22] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 2,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[0],
    /* parameters */ &kParameters[452],
    /* return matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [23] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 2,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[0],
    /* parameters */ &kParameters[453],
    /* return matcher indices */ &kMatcherIndices[75],
  },
  {
    /* [24] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[454],
    /* return matcher indices */ &kMatcherIndices[113],
  },
  {
    /* [25] */
    /* num parameters */ 3,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[286],
    /* return matcher indices */ &kMatcherIndices[47],
  },
  {
    /* [26] */
    /* num parameters */ 3,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[289],
    /* return matcher indices */ &kMatcherIndices[47],
  },
  {
    /* [27] */
    /* num parameters */ 4,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[150],
    /* return matcher indices */ &kMatcherIndices[47],
  },
  {
    /* [28] */
    /* num parameters */ 3,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[292],
    /* return matcher indices */ &kMatcherIndices[47],
  },
  {
    /* [29] */
    /* num parameters */ 3,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[295],
    /* return matcher indices */ &kMatcherIndices[47],
  },
  {
    /* [30] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[304],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [31] */
    /* num parameters */ 4,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[194],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [32] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[393],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [33] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[395],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [34] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[313],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [35] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[397],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [36] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[405],
    /* return matcher indices */ &kMatcherIndices[39],
  },
  {
    /* [37] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[407],
    /* return matcher indices */ &kMatcherIndices[39],
  },
  {
    /* [38] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[322],
    /* return matcher indices */ &kMatcherIndices[39],
  },
  {
    /* [39] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[409],
    /* return matcher indices */ &kMatcherIndices[39],
  },
  {
    /* [40] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[411],
    /* return matcher indices */ &kMatcherIndices[43],
  },
  {
    /* [41] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[427],
    /* return matcher indices */ &kMatcherIndices[43],
  },
  {
    /* [42] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[331],
    /* return matcher indices */ &kMatcherIndices[43],
  },
  {
    /* [43] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[403],
    /* return matcher indices */ &kMatcherIndices[43],
  },
  {
    /* [44] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[369],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [45] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[328],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [46] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[319],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [47] */
    /* num parameters */ 4,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[234],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [48] */
    /* num parameters */ 4,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[214],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [49] */
    /* num parameters */ 5,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[60],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [50] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[307],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [51] */
    /* num parameters */ 4,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[170],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [52] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[277],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [53] */
    /* num parameters */ 4,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[154],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [54] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[274],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [55] */
    /* num parameters */ 4,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[166],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [56] */
    /* num parameters */ 4,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[190],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [57] */
    /* num parameters */ 5,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[85],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [58] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[316],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [59] */
    /* num parameters */ 4,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[226],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [60] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[325],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [61] */
    /* num parameters */ 4,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[174],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [62] */
    /* num parameters */ 5,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[100],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [63] */
    /* num parameters */ 5,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[90],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [64] */
    /* num parameters */ 6,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[43],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [65] */
    /* num parameters */ 4,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[218],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [66] */
    /* num parameters */ 5,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[135],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [67] */
    /* num parameters */ 4,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[202],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [68] */
    /* num parameters */ 5,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[95],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [69] */
    /* num parameters */ 4,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[222],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [70] */
    /* num parameters */ 5,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[125],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [71] */
    /* num parameters */ 5,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[65],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [72] */
    /* num parameters */ 6,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[37],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [73] */
    /* num parameters */ 4,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[198],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [74] */
    /* num parameters */ 5,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[75],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [75] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[256],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [76] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[340],
    /* return matcher indices */ nullptr,
  },
  {
    /* [77] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[259],
    /* return matcher indices */ nullptr,
  },
  {
    /* [78] */
    /* num parameters */ 4,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[178],
    /* return matcher indices */ nullptr,
  },
  {
    /* [79] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[262],
    /* return matcher indices */ nullptr,
  },
  {
    /* [80] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[238],
    /* return matcher indices */ nullptr,
  },
  {
    /* [81] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[346],
    /* return matcher indices */ nullptr,
  },
  {
    /* [82] */
    /* num parameters */ 4,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[162],
    /* return matcher indices */ nullptr,
  },
  {
    /* [83] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[265],
    /* return matcher indices */ nullptr,
  },
  {
    /* [84] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[268],
    /* return matcher indices */ nullptr,
  },
  {
    /* [85] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[271],
    /* return matcher indices */ nullptr,
  },
  {
    /* [86] */
    /* num parameters */ 4,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[158],
    /* return matcher indices */ nullptr,
  },
  {
    /* [87] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[283],
    /* return matcher indices */ nullptr,
  },
  {
    /* [88] */
    /* num parameters */ 1,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[431],
    /* return matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [89] */
    /* num parameters */ 1,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[461],
    /* return matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [90] */
    /* num parameters */ 1,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[462],
    /* return matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [91] */
    /* num parameters */ 1,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[463],
    /* return matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [92] */
    /* num parameters */ 1,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[464],
    /* return matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [93] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[465],
    /* return matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [94] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[466],
    /* return matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [95] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[467],
    /* return matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [96] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[468],
    /* return matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [97] */
    /* num parameters */ 4,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[230],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [98] */
    /* num parameters */ 5,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[105],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [99] */
    /* num parameters */ 5,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[130],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [100] */
    /* num parameters */ 6,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[49],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [101] */
    /* num parameters */ 4,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[210],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [102] */
    /* num parameters */ 5,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[80],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [103] */
    /* num parameters */ 4,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[186],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [104] */
    /* num parameters */ 5,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[120],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [105] */
    /* num parameters */ 5,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[115],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [106] */
    /* num parameters */ 6,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[7],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [107] */
    /* num parameters */ 6,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[19],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [108] */
    /* num parameters */ 7,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[0],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [109] */
    /* num parameters */ 5,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[145],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [110] */
    /* num parameters */ 6,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[31],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [111] */
    /* num parameters */ 5,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[140],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [112] */
    /* num parameters */ 6,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[13],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [113] */
    /* num parameters */ 4,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[206],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [114] */
    /* num parameters */ 5,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[70],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [115] */
    /* num parameters */ 5,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[55],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [116] */
    /* num parameters */ 6,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[25],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [117] */
    /* num parameters */ 4,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[182],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [118] */
    /* num parameters */ 5,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[110],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [119] */
    /* num parameters */ 1,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[455],
    /* return matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [120] */
    /* num parameters */ 1,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[456],
    /* return matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [121] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[457],
    /* return matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [122] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[458],
    /* return matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [123] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 2,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[0],
    /* parameters */ &kParameters[459],
    /* return matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [124] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[391],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [125] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[389],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [126] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[537],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [127] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[536],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [128] */
    /* num parameters */ 1,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[0],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[535],
    /* return matcher indices */ &kMatcherIndices[3],
  },
  {
    /* [129] */
    /* num parameters */ 1,
    /* num open types */ 1,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[0],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[534],
    /* return matcher indices */ &kMatcherIndices[2],
  },
  {
    /* [130] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[539],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [131] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[538],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [132] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[399],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [133] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[401],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [134] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[385],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [135] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[383],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [136] */
    /* num parameters */ 3,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[301],
    /* return matcher indices */ &kMatcherIndices[3],
  },
  {
    /* [137] */
    /* num parameters */ 3,
    /* num open types */ 1,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[298],
    /* return matcher indices */ &kMatcherIndices[2],
  },
  {
    /* [138] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[532],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [139] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[531],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [140] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[530],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [141] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[529],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [142] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[528],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [143] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[527],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [144] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[526],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [145] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[525],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [146] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[524],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [147] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[523],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [148] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[522],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [149] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[521],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [150] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[520],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [151] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[519],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [152] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[518],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [153] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[517],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [154] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[253],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [155] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[250],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [156] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[516],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [157] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[515],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [158] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[280],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [159] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[241],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [160] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[514],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [161] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[513],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [162] */
    /* num parameters */ 2,
    /* num open types */ 1,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[0],
    /* open numbers */ &kOpenNumbers[3],
    /* parameters */ &kParameters[377],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [163] */
    /* num parameters */ 2,
    /* num open types */ 1,
    /* num open numbers */ 2,
    /* open types */ &kOpenTypes[0],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[375],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [164] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[512],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [165] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[511],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [166] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[510],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [167] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[509],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [168] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[508],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [169] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[507],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [170] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[506],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [171] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[505],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [172] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[504],
    /* return matcher indices */ &kMatcherIndices[1],
  },
  {
    /* [173] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[503],
    /* return matcher indices */ &kMatcherIndices[24],
  },
  {
    /* [174] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[502],
    /* return matcher indices */ &kMatcherIndices[1],
  },
  {
    /* [175] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[501],
    /* return matcher indices */ &kMatcherIndices[24],
  },
  {
    /* [176] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[500],
    /* return matcher indices */ &kMatcherIndices[1],
  },
  {
    /* [177] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[499],
    /* return matcher indices */ &kMatcherIndices[24],
  },
  {
    /* [178] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[498],
    /* return matcher indices */ &kMatcherIndices[1],
  },
  {
    /* [179] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[497],
    /* return matcher indices */ &kMatcherIndices[24],
  },
  {
    /* [180] */
    /* num parameters */ 2,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[0],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[373],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [181] */
    /* num parameters */ 2,
    /* num open types */ 1,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[0],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[371],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [182] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[496],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [183] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[495],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [184] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[494],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [185] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[493],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [186] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[492],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [187] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[491],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [188] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[541],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [189] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[540],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [190] */
    /* num parameters */ 2,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[355],
    /* return matcher indices */ &kMatcherIndices[3],
  },
  {
    /* [191] */
    /* num parameters */ 2,
    /* num open types */ 1,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[353],
    /* return matcher indices */ &kMatcherIndices[2],
  },
  {
    /* [192] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[334],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [193] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[337],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [194] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[3],
    /* parameters */ &kParameters[351],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [195] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 2,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[349],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [196] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[543],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [197] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[542],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [198] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[474],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [199] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[473],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [200] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[545],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [201] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[544],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [202] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[449],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [203] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[447],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [204] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[470],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [205] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[460],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [206] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[472],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [207] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[471],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [208] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[359],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [209] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[361],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [210] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[363],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [211] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[365],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [212] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[550],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [213] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[549],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [214] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[482],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [215] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[481],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [216] */
    /* num parameters */ 3,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[3],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[247],
    /* return matcher indices */ &kMatcherIndices[3],
  },
  {
    /* [217] */
    /* num parameters */ 3,
    /* num open types */ 1,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[3],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[244],
    /* return matcher indices */ &kMatcherIndices[2],
  },
  {
    /* [218] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[480],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [219] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[479],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [220] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[478],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [221] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[477],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [222] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[476],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [223] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[475],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [224] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[310],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [225] */
    /* num parameters */ 3,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[343],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [226] */
    /* num parameters */ 1,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[0],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[484],
    /* return matcher indices */ &kMatcherIndices[3],
  },
  {
    /* [227] */
    /* num parameters */ 1,
    /* num open types */ 1,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[0],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[483],
    /* return matcher indices */ &kMatcherIndices[2],
  },
  {
    /* [228] */
    /* num parameters */ 2,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[367],
    /* return matcher indices */ &kMatcherIndices[3],
  },
  {
    /* [229] */
    /* num parameters */ 2,
    /* num open types */ 1,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[357],
    /* return matcher indices */ &kMatcherIndices[2],
  },
  {
    /* [230] */
    /* num parameters */ 1,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[552],
    /* return matcher indices */ &kMatcherIndices[3],
  },
  {
    /* [231] */
    /* num parameters */ 1,
    /* num open types */ 1,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[551],
    /* return matcher indices */ &kMatcherIndices[2],
  },
  {
    /* [232] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[488],
    /* return matcher indices */ &kMatcherIndices[28],
  },
  {
    /* [233] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[486],
    /* return matcher indices */ &kMatcherIndices[28],
  },
  {
    /* [234] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[487],
    /* return matcher indices */ &kMatcherIndices[28],
  },
  {
    /* [235] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[445],
    /* return matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [236] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[443],
    /* return matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [237] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[440],
    /* return matcher indices */ &kMatcherIndices[115],
  },
  {
    /* [238] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[438],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [239] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[436],
    /* return matcher indices */ &kMatcherIndices[29],
  },
  {
    /* [240] */
    /* num parameters */ 0,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[553],
    /* return matcher indices */ nullptr,
  },
  {
    /* [241] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[485],
    /* return matcher indices */ &kMatcherIndices[28],
  },
  {
    /* [242] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[489],
    /* return matcher indices */ &kMatcherIndices[28],
  },
  {
    /* [243] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[490],
    /* return matcher indices */ &kMatcherIndices[7],
  },
  {
    /* [244] */
    /* num parameters */ 1,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[1],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[469],
    /* return matcher indices */ &kMatcherIndices[40],
  },
  {
    /* [245] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[381],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [246] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[533],
    /* return matcher indices */ &kMatcherIndices[9],
  },
  {
    /* [247] */
    /* num parameters */ 2,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[387],
    /* return matcher indices */ &kMatcherIndices[16],
  },
  {
    /* [248] */
    /* num parameters */ 1,
    /* num open types */ 1,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[2],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[546],
    /* return matcher indices */ &kMatcherIndices[28],
  },
  {
    /* [249] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[547],
    /* return matcher indices */ &kMatcherIndices[1],
  },
  {
    /* [250] */
    /* num parameters */ 1,
    /* num open types */ 0,
    /* num open numbers */ 1,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[2],
    /* parameters */ &kParameters[548],
    /* return matcher indices */ &kMatcherIndices[1],
  },
  {
    /* [251] */
    /* num parameters */ 0,
    /* num open types */ 0,
    /* num open numbers */ 0,
    /* open types */ &kOpenTypes[4],
    /* open numbers */ &kOpenNumbers[4],
    /* parameters */ &kParameters[553],
    /* return matcher indices */ nullptr,
  },
};

constexpr IntrinsicInfo kIntrinsics[] = {
  {
    /* [0] */
    /* fn abs<T : fiu32>(T) -> T */
    /* fn abs<N : num, T : fiu32>(vec<N, T>) -> vec<N, T> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[230],
  },
  {
    /* [1] */
    /* fn acos(f32) -> f32 */
    /* fn acos<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[212],
  },
  {
    /* [2] */
    /* fn all<N : num>(vec<N, bool>) -> bool */
    /* num overloads */ 1,
    /* overloads */ &kOverloads[250],
  },
  {
    /* [3] */
    /* fn any<N : num>(vec<N, bool>) -> bool */
    /* num overloads */ 1,
    /* overloads */ &kOverloads[249],
  },
  {
    /* [4] */
    /* fn arrayLength<T>(array<T>) -> u32 */
    /* num overloads */ 1,
    /* overloads */ &kOverloads[248],
  },
  {
    /* [5] */
    /* fn asin(f32) -> f32 */
    /* fn asin<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[200],
  },
  {
    /* [6] */
    /* fn atan(f32) -> f32 */
    /* fn atan<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[196],
  },
  {
    /* [7] */
    /* fn atan2(f32, f32) -> f32 */
    /* fn atan2<N : num>(vec<N, f32>, vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[124],
  },
  {
    /* [8] */
    /* fn ceil(f32) -> f32 */
    /* fn ceil<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[188],
  },
  {
    /* [9] */
    /* fn clamp<T : fiu32>(T, T, T) -> T */
    /* fn clamp<N : num, T : fiu32>(vec<N, T>, vec<N, T>, vec<N, T>) -> vec<N, T> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[136],
  },
  {
    /* [10] */
    /* fn cos(f32) -> f32 */
    /* fn cos<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[130],
  },
  {
    /* [11] */
    /* fn cosh(f32) -> f32 */
    /* fn cosh<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[126],
  },
  {
    /* [12] */
    /* fn countOneBits<T : iu32>(T) -> T */
    /* fn countOneBits<N : num, T : iu32>(vec<N, T>) -> vec<N, T> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[128],
  },
  {
    /* [13] */
    /* fn cross(vec3<f32>, vec3<f32>) -> vec3<f32> */
    /* num overloads */ 1,
    /* overloads */ &kOverloads[247],
  },
  {
    /* [14] */
    /* fn determinant<N : num>(mat<N, N, f32>) -> f32 */
    /* num overloads */ 1,
    /* overloads */ &kOverloads[246],
  },
  {
    /* [15] */
    /* fn distance(f32, f32) -> f32 */
    /* fn distance<N : num>(vec<N, f32>, vec<N, f32>) -> f32 */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[134],
  },
  {
    /* [16] */
    /* fn dot<N : num>(vec<N, f32>, vec<N, f32>) -> f32 */
    /* num overloads */ 1,
    /* overloads */ &kOverloads[245],
  },
  {
    /* [17] */
    /* fn dpdx(f32) -> f32 */
    /* fn dpdx<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[138],
  },
  {
    /* [18] */
    /* fn dpdxCoarse(f32) -> f32 */
    /* fn dpdxCoarse<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[140],
  },
  {
    /* [19] */
    /* fn dpdxFine(f32) -> f32 */
    /* fn dpdxFine<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[142],
  },
  {
    /* [20] */
    /* fn dpdy(f32) -> f32 */
    /* fn dpdy<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[144],
  },
  {
    /* [21] */
    /* fn dpdyCoarse(f32) -> f32 */
    /* fn dpdyCoarse<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[146],
  },
  {
    /* [22] */
    /* fn dpdyFine(f32) -> f32 */
    /* fn dpdyFine<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[148],
  },
  {
    /* [23] */
    /* fn exp(f32) -> f32 */
    /* fn exp<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[150],
  },
  {
    /* [24] */
    /* fn exp2(f32) -> f32 */
    /* fn exp2<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[152],
  },
  {
    /* [25] */
    /* fn faceForward(f32, f32, f32) -> f32 */
    /* fn faceForward<N : num>(vec<N, f32>, vec<N, f32>, vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[154],
  },
  {
    /* [26] */
    /* fn floor(f32) -> f32 */
    /* fn floor<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[156],
  },
  {
    /* [27] */
    /* fn fma(f32, f32, f32) -> f32 */
    /* fn fma<N : num>(vec<N, f32>, vec<N, f32>, vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[158],
  },
  {
    /* [28] */
    /* fn fract(f32) -> f32 */
    /* fn fract<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[160],
  },
  {
    /* [29] */
    /* fn frexp<T : iu32, S : storage_class>(f32, ptr<S, T>) -> f32 */
    /* fn frexp<N : num, T : iu32, S : storage_class>(vec<N, f32>, ptr<S, vec<N, T>>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[162],
  },
  {
    /* [30] */
    /* fn fwidth(f32) -> f32 */
    /* fn fwidth<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[164],
  },
  {
    /* [31] */
    /* fn fwidthCoarse(f32) -> f32 */
    /* fn fwidthCoarse<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[166],
  },
  {
    /* [32] */
    /* fn fwidthFine(f32) -> f32 */
    /* fn fwidthFine<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[168],
  },
  {
    /* [33] */
    /* fn inverseSqrt(f32) -> f32 */
    /* fn inverseSqrt<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[170],
  },
  {
    /* [34] */
    /* fn isFinite(f32) -> bool */
    /* fn isFinite<N : num>(vec<N, f32>) -> vec<N, bool> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[172],
  },
  {
    /* [35] */
    /* fn isInf(f32) -> bool */
    /* fn isInf<N : num>(vec<N, f32>) -> vec<N, bool> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[174],
  },
  {
    /* [36] */
    /* fn isNan(f32) -> bool */
    /* fn isNan<N : num>(vec<N, f32>) -> vec<N, bool> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[176],
  },
  {
    /* [37] */
    /* fn isNormal(f32) -> bool */
    /* fn isNormal<N : num>(vec<N, f32>) -> vec<N, bool> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[178],
  },
  {
    /* [38] */
    /* fn ldexp<T : iu32>(f32, T) -> f32 */
    /* fn ldexp<N : num, T : iu32>(vec<N, f32>, vec<N, T>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[180],
  },
  {
    /* [39] */
    /* fn length(f32) -> f32 */
    /* fn length<N : num>(vec<N, f32>) -> f32 */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[182],
  },
  {
    /* [40] */
    /* fn log(f32) -> f32 */
    /* fn log<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[184],
  },
  {
    /* [41] */
    /* fn log2(f32) -> f32 */
    /* fn log2<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[186],
  },
  {
    /* [42] */
    /* fn max<T : fiu32>(T, T) -> T */
    /* fn max<N : num, T : fiu32>(vec<N, T>, vec<N, T>) -> vec<N, T> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[228],
  },
  {
    /* [43] */
    /* fn min<T : fiu32>(T, T) -> T */
    /* fn min<N : num, T : fiu32>(vec<N, T>, vec<N, T>) -> vec<N, T> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[190],
  },
  {
    /* [44] */
    /* fn mix(f32, f32, f32) -> f32 */
    /* fn mix<N : num>(vec<N, f32>, vec<N, f32>, vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[192],
  },
  {
    /* [45] */
    /* fn modf<S : storage_class>(f32, ptr<S, f32>) -> f32 */
    /* fn modf<N : num, S : storage_class>(vec<N, f32>, ptr<S, vec<N, f32>>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[194],
  },
  {
    /* [46] */
    /* fn normalize<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 1,
    /* overloads */ &kOverloads[243],
  },
  {
    /* [47] */
    /* fn pack2x16float(vec2<f32>) -> u32 */
    /* num overloads */ 1,
    /* overloads */ &kOverloads[242],
  },
  {
    /* [48] */
    /* fn pack2x16snorm(vec2<f32>) -> u32 */
    /* num overloads */ 1,
    /* overloads */ &kOverloads[232],
  },
  {
    /* [49] */
    /* fn pack2x16unorm(vec2<f32>) -> u32 */
    /* num overloads */ 1,
    /* overloads */ &kOverloads[234],
  },
  {
    /* [50] */
    /* fn pack4x8snorm(vec4<f32>) -> u32 */
    /* num overloads */ 1,
    /* overloads */ &kOverloads[233],
  },
  {
    /* [51] */
    /* fn pack4x8unorm(vec4<f32>) -> u32 */
    /* num overloads */ 1,
    /* overloads */ &kOverloads[241],
  },
  {
    /* [52] */
    /* fn pow(f32, f32) -> f32 */
    /* fn pow<N : num>(vec<N, f32>, vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[208],
  },
  {
    /* [53] */
    /* fn reflect(f32, f32) -> f32 */
    /* fn reflect<N : num>(vec<N, f32>, vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[210],
  },
  {
    /* [54] */
    /* fn reverseBits<T : iu32>(T) -> T */
    /* fn reverseBits<N : num, T : iu32>(vec<N, T>) -> vec<N, T> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[226],
  },
  {
    /* [55] */
    /* fn round(f32) -> f32 */
    /* fn round<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[214],
  },
  {
    /* [56] */
    /* fn select<T : scalar>(T, T, bool) -> T */
    /* fn select<N : num, T : scalar>(vec<N, T>, vec<N, T>, vec<N, bool>) -> vec<N, T> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[216],
  },
  {
    /* [57] */
    /* fn sign(f32) -> f32 */
    /* fn sign<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[218],
  },
  {
    /* [58] */
    /* fn sin(f32) -> f32 */
    /* fn sin<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[220],
  },
  {
    /* [59] */
    /* fn sinh(f32) -> f32 */
    /* fn sinh<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[222],
  },
  {
    /* [60] */
    /* fn smoothStep(f32, f32, f32) -> f32 */
    /* fn smoothStep<N : num>(vec<N, f32>, vec<N, f32>, vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[224],
  },
  {
    /* [61] */
    /* fn sqrt(f32) -> f32 */
    /* fn sqrt<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[198],
  },
  {
    /* [62] */
    /* fn step(f32, f32) -> f32 */
    /* fn step<N : num>(vec<N, f32>, vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[132],
  },
  {
    /* [63] */
    /* fn storageBarrier() */
    /* num overloads */ 1,
    /* overloads */ &kOverloads[251],
  },
  {
    /* [64] */
    /* fn tan(f32) -> f32 */
    /* fn tan<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[206],
  },
  {
    /* [65] */
    /* fn tanh(f32) -> f32 */
    /* fn tanh<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[204],
  },
  {
    /* [66] */
    /* fn trunc(f32) -> f32 */
    /* fn trunc<N : num>(vec<N, f32>) -> vec<N, f32> */
    /* num overloads */ 2,
    /* overloads */ &kOverloads[202],
  },
  {
    /* [67] */
    /* fn unpack2x16float(u32) -> vec2<f32> */
    /* num overloads */ 1,
    /* overloads */ &kOverloads[235],
  },
  {
    /* [68] */
    /* fn unpack2x16snorm(u32) -> vec2<f32> */
    /* num overloads */ 1,
    /* overloads */ &kOverloads[236],
  },
  {
    /* [69] */
    /* fn unpack2x16unorm(u32) -> vec2<f32> */
    /* num overloads */ 1,
    /* overloads */ &kOverloads[237],
  },
  {
    /* [70] */
    /* fn unpack4x8snorm(u32) -> vec4<f32> */
    /* num overloads */ 1,
    /* overloads */ &kOverloads[238],
  },
  {
    /* [71] */
    /* fn unpack4x8unorm(u32) -> vec4<f32> */
    /* num overloads */ 1,
    /* overloads */ &kOverloads[239],
  },
  {
    /* [72] */
    /* fn workgroupBarrier() */
    /* num overloads */ 1,
    /* overloads */ &kOverloads[240],
  },
  {
    /* [73] */
    /* fn textureDimensions<T : fiu32>(texture: texture_1d<T>) -> i32 */
    /* fn textureDimensions<T : fiu32>(texture: texture_2d<T>) -> vec2<i32> */
    /* fn textureDimensions<T : fiu32>(texture: texture_2d<T>, level: i32) -> vec2<i32> */
    /* fn textureDimensions<T : fiu32>(texture: texture_2d_array<T>) -> vec2<i32> */
    /* fn textureDimensions<T : fiu32>(texture: texture_2d_array<T>, level: i32) -> vec2<i32> */
    /* fn textureDimensions<T : fiu32>(texture: texture_3d<T>) -> vec3<i32> */
    /* fn textureDimensions<T : fiu32>(texture: texture_3d<T>, level: i32) -> vec3<i32> */
    /* fn textureDimensions<T : fiu32>(texture: texture_cube<T>) -> vec3<i32> */
    /* fn textureDimensions<T : fiu32>(texture: texture_cube<T>, level: i32) -> vec3<i32> */
    /* fn textureDimensions<T : fiu32>(texture: texture_cube_array<T>) -> vec3<i32> */
    /* fn textureDimensions<T : fiu32>(texture: texture_cube_array<T>, level: i32) -> vec3<i32> */
    /* fn textureDimensions<T : fiu32>(texture: texture_multisampled_2d<T>) -> vec2<i32> */
    /* fn textureDimensions(texture: texture_depth_2d) -> vec2<i32> */
    /* fn textureDimensions(texture: texture_depth_2d, level: i32) -> vec2<i32> */
    /* fn textureDimensions(texture: texture_depth_2d_array) -> vec2<i32> */
    /* fn textureDimensions(texture: texture_depth_2d_array, level: i32) -> vec2<i32> */
    /* fn textureDimensions(texture: texture_depth_cube) -> vec3<i32> */
    /* fn textureDimensions(texture: texture_depth_cube, level: i32) -> vec3<i32> */
    /* fn textureDimensions(texture: texture_depth_cube_array) -> vec3<i32> */
    /* fn textureDimensions(texture: texture_depth_cube_array, level: i32) -> vec3<i32> */
    /* fn textureDimensions<F : texel_format, A : read_or_write>(texture: texture_storage_1d<F, A>) -> i32 */
    /* fn textureDimensions<F : texel_format, A : read_or_write>(texture: texture_storage_2d<F, A>) -> vec2<i32> */
    /* fn textureDimensions<F : texel_format, A : read_or_write>(texture: texture_storage_2d_array<F, A>) -> vec2<i32> */
    /* fn textureDimensions<F : texel_format, A : read_or_write>(texture: texture_storage_3d<F, A>) -> vec3<i32> */
    /* fn textureDimensions(texture: texture_external) -> vec2<i32> */
    /* num overloads */ 25,
    /* overloads */ &kOverloads[0],
  },
  {
    /* [74] */
    /* fn textureNumLayers<T : fiu32>(texture: texture_2d_array<T>) -> i32 */
    /* fn textureNumLayers<T : fiu32>(texture: texture_cube_array<T>) -> i32 */
    /* fn textureNumLayers(texture: texture_depth_2d_array) -> i32 */
    /* fn textureNumLayers(texture: texture_depth_cube_array) -> i32 */
    /* fn textureNumLayers<F : texel_format, A : read_or_write>(texture: texture_storage_2d_array<F, A>) -> i32 */
    /* num overloads */ 5,
    /* overloads */ &kOverloads[119],
  },
  {
    /* [75] */
    /* fn textureNumLevels<T : fiu32>(texture: texture_2d<T>) -> i32 */
    /* fn textureNumLevels<T : fiu32>(texture: texture_2d_array<T>) -> i32 */
    /* fn textureNumLevels<T : fiu32>(texture: texture_3d<T>) -> i32 */
    /* fn textureNumLevels<T : fiu32>(texture: texture_cube<T>) -> i32 */
    /* fn textureNumLevels<T : fiu32>(texture: texture_cube_array<T>) -> i32 */
    /* fn textureNumLevels(texture: texture_depth_2d) -> i32 */
    /* fn textureNumLevels(texture: texture_depth_2d_array) -> i32 */
    /* fn textureNumLevels(texture: texture_depth_cube) -> i32 */
    /* fn textureNumLevels(texture: texture_depth_cube_array) -> i32 */
    /* num overloads */ 9,
    /* overloads */ &kOverloads[88],
  },
  {
    /* [76] */
    /* fn textureNumSamples<T : fiu32>(texture: texture_multisampled_2d<T>) -> i32 */
    /* num overloads */ 1,
    /* overloads */ &kOverloads[244],
  },
  {
    /* [77] */
    /* fn textureSample(texture: texture_1d<f32>, sampler: sampler, coords: f32) -> vec4<f32> */
    /* fn textureSample(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>) -> vec4<f32> */
    /* fn textureSample(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>, offset: vec2<i32>) -> vec4<f32> */
    /* fn textureSample(texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: i32) -> vec4<f32> */
    /* fn textureSample(texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: i32, offset: vec2<i32>) -> vec4<f32> */
    /* fn textureSample(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>) -> vec4<f32> */
    /* fn textureSample(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>, offset: vec3<i32>) -> vec4<f32> */
    /* fn textureSample(texture: texture_cube<f32>, sampler: sampler, coords: vec3<f32>) -> vec4<f32> */
    /* fn textureSample(texture: texture_cube_array<f32>, sampler: sampler, coords: vec3<f32>, array_index: i32) -> vec4<f32> */
    /* fn textureSample(texture: texture_depth_2d, sampler: sampler, coords: vec2<f32>) -> f32 */
    /* fn textureSample(texture: texture_depth_2d, sampler: sampler, coords: vec2<f32>, offset: vec2<i32>) -> f32 */
    /* fn textureSample(texture: texture_depth_2d_array, sampler: sampler, coords: vec2<f32>, array_index: i32) -> f32 */
    /* fn textureSample(texture: texture_depth_2d_array, sampler: sampler, coords: vec2<f32>, array_index: i32, offset: vec2<i32>) -> f32 */
    /* fn textureSample(texture: texture_depth_cube, sampler: sampler, coords: vec3<f32>) -> f32 */
    /* fn textureSample(texture: texture_depth_cube_array, sampler: sampler, coords: vec3<f32>, array_index: i32) -> f32 */
    /* fn textureSample(texture: texture_external, sampler: sampler, coords: vec2<f32>) -> vec4<f32> */
    /* num overloads */ 16,
    /* overloads */ &kOverloads[45],
  },
  {
    /* [78] */
    /* fn textureSampleBias(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>, bias: f32) -> vec4<f32> */
    /* fn textureSampleBias(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>, bias: f32, offset: vec2<i32>) -> vec4<f32> */
    /* fn textureSampleBias(texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: i32, bias: f32) -> vec4<f32> */
    /* fn textureSampleBias(texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: i32, bias: f32, offset: vec2<i32>) -> vec4<f32> */
    /* fn textureSampleBias(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>, bias: f32) -> vec4<f32> */
    /* fn textureSampleBias(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>, bias: f32, offset: vec3<i32>) -> vec4<f32> */
    /* fn textureSampleBias(texture: texture_cube<f32>, sampler: sampler, coords: vec3<f32>, bias: f32) -> vec4<f32> */
    /* fn textureSampleBias(texture: texture_cube_array<f32>, sampler: sampler, coords: vec3<f32>, array_index: i32, bias: f32) -> vec4<f32> */
    /* num overloads */ 8,
    /* overloads */ &kOverloads[97],
  },
  {
    /* [79] */
    /* fn textureSampleCompare(texture: texture_depth_2d, sampler: sampler_comparison, coords: vec2<f32>, depth_ref: f32) -> f32 */
    /* fn textureSampleCompare(texture: texture_depth_2d, sampler: sampler_comparison, coords: vec2<f32>, depth_ref: f32, offset: vec2<i32>) -> f32 */
    /* fn textureSampleCompare(texture: texture_depth_2d_array, sampler: sampler_comparison, coords: vec2<f32>, array_index: i32, depth_ref: f32) -> f32 */
    /* fn textureSampleCompare(texture: texture_depth_2d_array, sampler: sampler_comparison, coords: vec2<f32>, array_index: i32, depth_ref: f32, offset: vec2<i32>) -> f32 */
    /* fn textureSampleCompare(texture: texture_depth_cube, sampler: sampler_comparison, coords: vec3<f32>, depth_ref: f32) -> f32 */
    /* fn textureSampleCompare(texture: texture_depth_cube_array, sampler: sampler_comparison, coords: vec3<f32>, array_index: i32, depth_ref: f32) -> f32 */
    /* num overloads */ 6,
    /* overloads */ &kOverloads[113],
  },
  {
    /* [80] */
    /* fn textureSampleGrad(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>, ddx: vec2<f32>, ddy: vec2<f32>) -> vec4<f32> */
    /* fn textureSampleGrad(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>, ddx: vec2<f32>, ddy: vec2<f32>, offset: vec2<i32>) -> vec4<f32> */
    /* fn textureSampleGrad(texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: i32, ddx: vec2<f32>, ddy: vec2<f32>) -> vec4<f32> */
    /* fn textureSampleGrad(texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: i32, ddx: vec2<f32>, ddy: vec2<f32>, offset: vec2<i32>) -> vec4<f32> */
    /* fn textureSampleGrad(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>, ddx: vec3<f32>, ddy: vec3<f32>) -> vec4<f32> */
    /* fn textureSampleGrad(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>, ddx: vec3<f32>, ddy: vec3<f32>, offset: vec3<i32>) -> vec4<f32> */
    /* fn textureSampleGrad(texture: texture_cube<f32>, sampler: sampler, coords: vec3<f32>, ddx: vec3<f32>, ddy: vec3<f32>) -> vec4<f32> */
    /* fn textureSampleGrad(texture: texture_cube_array<f32>, sampler: sampler, coords: vec3<f32>, array_index: i32, ddx: vec3<f32>, ddy: vec3<f32>) -> vec4<f32> */
    /* num overloads */ 8,
    /* overloads */ &kOverloads[105],
  },
  {
    /* [81] */
    /* fn textureSampleLevel(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>, level: f32) -> vec4<f32> */
    /* fn textureSampleLevel(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>, level: f32, offset: vec2<i32>) -> vec4<f32> */
    /* fn textureSampleLevel(texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: i32, level: f32) -> vec4<f32> */
    /* fn textureSampleLevel(texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: i32, level: f32, offset: vec2<i32>) -> vec4<f32> */
    /* fn textureSampleLevel(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>, level: f32) -> vec4<f32> */
    /* fn textureSampleLevel(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>, level: f32, offset: vec3<i32>) -> vec4<f32> */
    /* fn textureSampleLevel(texture: texture_cube<f32>, sampler: sampler, coords: vec3<f32>, level: f32) -> vec4<f32> */
    /* fn textureSampleLevel(texture: texture_cube_array<f32>, sampler: sampler, coords: vec3<f32>, array_index: i32, level: f32) -> vec4<f32> */
    /* fn textureSampleLevel(texture: texture_depth_2d, sampler: sampler, coords: vec2<f32>, level: i32) -> f32 */
    /* fn textureSampleLevel(texture: texture_depth_2d, sampler: sampler, coords: vec2<f32>, level: i32, offset: vec2<i32>) -> f32 */
    /* fn textureSampleLevel(texture: texture_depth_2d_array, sampler: sampler, coords: vec2<f32>, array_index: i32, level: i32) -> f32 */
    /* fn textureSampleLevel(texture: texture_depth_2d_array, sampler: sampler, coords: vec2<f32>, array_index: i32, level: i32, offset: vec2<i32>) -> f32 */
    /* fn textureSampleLevel(texture: texture_depth_cube, sampler: sampler, coords: vec3<f32>, level: i32) -> f32 */
    /* fn textureSampleLevel(texture: texture_depth_cube_array, sampler: sampler, coords: vec3<f32>, array_index: i32, level: i32) -> f32 */
    /* fn textureSampleLevel(texture: texture_external, sampler: sampler, coords: vec2<f32>) -> vec4<f32> */
    /* num overloads */ 15,
    /* overloads */ &kOverloads[61],
  },
  {
    /* [82] */
    /* fn textureStore(texture: texture_storage_1d<f32_texel_format, write>, coords: i32, value: vec4<f32>) */
    /* fn textureStore(texture: texture_storage_2d<f32_texel_format, write>, coords: vec2<i32>, value: vec4<f32>) */
    /* fn textureStore(texture: texture_storage_2d_array<f32_texel_format, write>, coords: vec2<i32>, array_index: i32, value: vec4<f32>) */
    /* fn textureStore(texture: texture_storage_3d<f32_texel_format, write>, coords: vec3<i32>, value: vec4<f32>) */
    /* fn textureStore(texture: texture_storage_1d<i32_texel_format, write>, coords: i32, value: vec4<i32>) */
    /* fn textureStore(texture: texture_storage_2d<i32_texel_format, write>, coords: vec2<i32>, value: vec4<i32>) */
    /* fn textureStore(texture: texture_storage_2d_array<i32_texel_format, write>, coords: vec2<i32>, array_index: i32, value: vec4<i32>) */
    /* fn textureStore(texture: texture_storage_3d<i32_texel_format, write>, coords: vec3<i32>, value: vec4<i32>) */
    /* fn textureStore(texture: texture_storage_1d<u32_texel_format, write>, coords: i32, value: vec4<u32>) */
    /* fn textureStore(texture: texture_storage_2d<u32_texel_format, write>, coords: vec2<i32>, value: vec4<u32>) */
    /* fn textureStore(texture: texture_storage_2d_array<u32_texel_format, write>, coords: vec2<i32>, array_index: i32, value: vec4<u32>) */
    /* fn textureStore(texture: texture_storage_3d<u32_texel_format, write>, coords: vec3<i32>, value: vec4<u32>) */
    /* num overloads */ 12,
    /* overloads */ &kOverloads[76],
  },
  {
    /* [83] */
    /* fn textureLoad<T : fiu32>(texture: texture_1d<T>, coords: i32, level: i32) -> vec4<T> */
    /* fn textureLoad<T : fiu32>(texture: texture_2d<T>, coords: vec2<i32>, level: i32) -> vec4<T> */
    /* fn textureLoad<T : fiu32>(texture: texture_2d_array<T>, coords: vec2<i32>, array_index: i32, level: i32) -> vec4<T> */
    /* fn textureLoad<T : fiu32>(texture: texture_3d<T>, coords: vec3<i32>, level: i32) -> vec4<T> */
    /* fn textureLoad<T : fiu32>(texture: texture_multisampled_2d<T>, coords: vec2<i32>, sample_index: i32) -> vec4<T> */
    /* fn textureLoad(texture: texture_depth_2d, coords: vec2<i32>, level: i32) -> f32 */
    /* fn textureLoad(texture: texture_depth_2d_array, coords: vec2<i32>, array_index: i32, level: i32) -> f32 */
    /* fn textureLoad(texture: texture_storage_1d<f32_texel_format, read>, coords: i32) -> vec4<f32> */
    /* fn textureLoad(texture: texture_storage_2d<f32_texel_format, read>, coords: vec2<i32>) -> vec4<f32> */
    /* fn textureLoad(texture: texture_storage_2d_array<f32_texel_format, read>, coords: vec2<i32>, array_index: i32) -> vec4<f32> */
    /* fn textureLoad(texture: texture_storage_3d<f32_texel_format, read>, coords: vec3<i32>) -> vec4<f32> */
    /* fn textureLoad(texture: texture_storage_1d<i32_texel_format, read>, coords: i32) -> vec4<i32> */
    /* fn textureLoad(texture: texture_storage_2d<i32_texel_format, read>, coords: vec2<i32>) -> vec4<i32> */
    /* fn textureLoad(texture: texture_storage_2d_array<i32_texel_format, read>, coords: vec2<i32>, array_index: i32) -> vec4<i32> */
    /* fn textureLoad(texture: texture_storage_3d<i32_texel_format, read>, coords: vec3<i32>) -> vec4<i32> */
    /* fn textureLoad(texture: texture_storage_1d<u32_texel_format, read>, coords: i32) -> vec4<u32> */
    /* fn textureLoad(texture: texture_storage_2d<u32_texel_format, read>, coords: vec2<i32>) -> vec4<u32> */
    /* fn textureLoad(texture: texture_storage_2d_array<u32_texel_format, read>, coords: vec2<i32>, array_index: i32) -> vec4<u32> */
    /* fn textureLoad(texture: texture_storage_3d<u32_texel_format, read>, coords: vec3<i32>) -> vec4<u32> */
    /* fn textureLoad(texture: texture_external, coords: vec2<i32>) -> vec4<f32> */
    /* num overloads */ 20,
    /* overloads */ &kOverloads[25],
  },
};

// clang-format on
